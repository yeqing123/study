**练习28：(2) 创建一个Ex28_BlipCheck.java文件，**
**复制类Blip2并重命名为Ex28_BlipCheck（使其构造器成为public的）。复制Blips类并重命名为Blips2，**
**然后在Ex28_BlipCheck类中的main()方法中调用Blips2中的main()方法。删除Blips2中的//!标记，然后执行含有这几个错误行的程序。**
**接下来，注释掉Ex28_BlipCheck的默认构造器。执行并解释它可以运行的原因。注意，如果使用java命令行，编译后我们必须使用java io.Blips2执行程序，因为main()方法仍在Blips2类中。**
**必要时程序中Blips.out文件的路径也要做出相应的修改。**
```java
package io;
import java.io.*;

public class Ex28_BlipCheck implements Externalizable {
//	public Ex28_BlipCheck() {
//		System.out.println("BlipCheck constructor");
//	}
	public void writeExternal(ObjectOutput out) throws IOException {
		System.out.println("BlipCheck.writeExternal");
	}
	public void readExternal(ObjectInput in) 
			throws IOException, ClassNotFoundException {
		System.out.println("BlipCheck.readExternal");
	}
	public static void main(String[] args) throws IOException, ClassNotFoundException {
        // To make it run with Ant.
		Blips2.main(args);
	}

}


class Blips2 {

	public static void main(String[] args) throws IOException, ClassNotFoundException {
        System.out.println("Constructing objects: ");
        Blip1 b1 = new Blip1();
        Ex28_BlipCheck b2 = new Ex28_BlipCheck();
        ObjectOutputStream out = new ObjectOutputStream(
        		new FileOutputStream("./src/io/Blips.out"));
        System.out.println("Saving objects:");
        out.writeObject(b1);
        out.writeObject(b2);
        out.close();
        // Now get them back:
        ObjectInputStream in = new ObjectInputStream(
        		new FileInputStream("./src/io/Blips.out"));
        System.out.println("Recovering b1:");
        b1 = (Blip1)in.readObject();
        // OOPS! Throw an exception:
        System.out.println("Recovering b2:");
        b2 = (Ex28_BlipCheck)in.readObject();
	}

}/*Output:
Constructing objects: 
Blip1 constructor
Saving objects:
Blip1.writeExternal
BlipCheck.writeExternal
Recovering b1:
Blip1 constructor
Blip1.readExternal
Recovering b2:
BlipCheck.readExternal
*///
```
