# 18.15 总结
Java I/O流类库的确能满足我们的基本需求：我们可以通过控制台、文件、内存块，甚至因特网进行读写。通过继承，我们可以创建新类型的输入和输出对象。通过重新定义toString()方法，
我们甚至可以对流接受的对象进行简单扩充。当我们向一个期望收到字符串的方法传递一个对象时，会自动调用toString()方法（这时Java有限的自动类型转换功能）。

在I/O流类库的设计中，仍留有一些没有解决的问题。例如，如果我们打开一个文件时，如果一旦试图覆盖该文件就抛出一个异常。在Java中，我们可以使用File对象来判断某个文件是否存在，
但是如果我们直接用FileOutputStream或者FileWrite打开文件，则它肯定会被覆盖。

I/O流类库既让人喜又让人忧。它确实能做许多事情，而且具有可移植性。但是如果我们没有理解“装饰器”模式，那么这种设计就很不直观。因此，在学习和教学时也很费劲。
它也并不够完善，例如，我们应该不必编写像TextFile这样的应用（Java SE5中的PrintWrite向正确的方向迈进了一步，但是只是一部分的解决方案）。在Java SE5中有一个巨大的改进，
就是添加了*输出格式化*，而事实上其他所有语言的I/O包都提供了这种支持。

一旦我们理解了装饰器模式，并开始在某些情况下使用该类库，那么我们就能体会到它的灵活性，并从这个设计中受益了。到那个时候，为此额外多写几行代码的开销应该不会让人觉得太麻烦。

## （完）
---

### [上一节：18.14 Preferences](18.14_Preferences.md)

