# 18.12 对象序列化

当你创建对象是，只要你需要，它就会一直存在，直到程序终止时为止。但是在某些情况下，如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。
这样，下次运行程序时，该对象将被重建并且拥有与程序上次运行时相同的信息。当然，你可以通过将信息写入文件或数据库来达到相同的效果，但是在万物皆对象的精神中，
如果能将一个对象声明为“持久性”的，并为我们处理掉所有细节，那将会显得十分方便。

Java的***对象序列化***把那些实现了***Serializable***接口的对象转换成了一个字节序列，并可以在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可以通过网络进行；
这意味着序列化机制能自动弥补不同操作系统之间的差异。

就其本身来说，对象的序列化是非常有趣的，因为利用它可以实现***轻量级持久性（lightwight persistence）***。“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行；
它可以生存在程序的调用之间。说它是“轻量级”的，是因为不能用类似 **“persistence”** （持久）的关键字来简单地定义一个对象，并让系统自动维护其他细节问题（将来或许会实现）。
相反，对象必须在程序中显示地进行序列化（serialize）和反序列化（deserialize）。如果需要一个更严格的持久性机制，可以考虑像Hibernate之类的工具（参见http://hibernate.sourceforge.net）。

对象序列化的概念加入到编程语言中，主要是为了支持两种特性。一是Java的***远程方法调用(Remote Method Invocation, RMI)*** ，它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。
当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。在《Thinking in Enterprise Java》中有对RMI的具体讨论。二是，对于Java Beans来说，对象的序列化也是必需的（可参见第14章）。
使用一个Bean时，一般情况下是设计阶段对它的状态信息进行设置。这种状态信息必须保存下来，并在程序启动时进行后期恢复；这种具体工作就是由对象序列化完成的。

只要对象实现了**Serializable**接口（该接口仅仅是一个标记接口，没有任何方法），对象的序列化处理就会非常简单。当序列化的概念被加入到Java语言中时，许多标准库类都发生了改变，
以便具备序列化特性——其中包括所有基本数据类型的封装器、所有容器类以及许多其他的东西。甚至Class对象也可以被序列化。

要序列化一个对象，首先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内。这时，只需调用writeObject()即可将对象序列化，
并将其发送给OutputStream(对象化序列是基于字节的，因此需使用InputStream和OutputStream继承层次结构)。要反向进行该过程（即将一个序列还原为一个对象），
需要将一个InputStream封装在ObjectInputStream内，然后调用readObject()方法即可。最后我们会获得一个引用，它指向一个向上转型后的Object对象，因此必须向下转型为我们想要的对象。

对象序列化特别“聪明”的一个地方是它不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象；并且还可以对对象内包含的每个这样的引用进行追踪，以此类推。
这种情况有时被称为“对象网”，单个对象可与之建立连接，而且它还包含了对象的引用数组以及成员对象。如果必须保持一个自己的对象序列化机制，那么维护那些可追踪到所有连接的代码可能会显得非常麻烦。
然而，Java的对象序列化似乎找不出什么缺点，所以请尽量不要自己动手，让它用优化的算法自动维护整个对象网。下面这个例子通过对连接的对象生成一个worm(蠕虫)对象序列化机制进行测试。
每个对象都与worm中的下一段连接，同时又与属于不同类的对象（Data）引用数组连接：
```java
package io;
import java.io.*;
import java.util.*;

class Data implements Serializable {
	private int n;
	public Data(int n) { this.n = n; }
	public String toString() { return Integer.toString(n); }
}

public class Worm implements Serializable {
	private static Random rand = new Random(47);
	private char c;
	private Data[] d = {
			new Data(rand.nextInt(10)),
			new Data(rand.nextInt(10)),
			new Data(rand.nextInt(10))
	};
	private Worm next;
	// Value of i == number of segments
	public Worm(int i, char x) {
		System.out.println("Worm constructor: " + i);
		this.c = x;
		if(--i > 0)
		    this.next = new Worm(i, (char)(x + 1));
	}
	public Worm() {
		System.out.println("Default constructor");
	}
	public String toString() {
		StringBuilder result = new StringBuilder(":");
		result.append(c);
		result.append("(");
		for(Data dat : d)
			result.append(dat);
		result.append(")");
		if(next != null)
		    result.append(next);
		return result.toString();
	}
	public static void main(String[] args) throws ClassNotFoundException, IOException {
		ObjectOutputStream out = new ObjectOutputStream(
				new FileOutputStream("./src/io/worm.out"));
		Worm w = new Worm(6, 'a');
		System.out.println("w = " + w);
		out.writeObject("Worm storage\n");
		out.writeObject(w);
		out.close();   // Also flushes output
		ObjectInputStream in = new ObjectInputStream(
				new FileInputStream("./src/io/worm.out"));
		String s = (String)in.readObject();
		Worm w2 = (Worm)in.readObject();
		System.out.println(s + "w2 = " + w2);
		ByteArrayOutputStream bout = new ByteArrayOutputStream();
		ObjectOutputStream out2 = new ObjectOutputStream(bout);
		out2.writeObject("Worm storage\n");
		out2.writeObject(w);
		out2.flush();
		ObjectInputStream in2 = new ObjectInputStream(
				new ByteArrayInputStream(bout.toByteArray()));
		s = (String)in2.readObject();
		Worm w3 = (Worm)in2.readObject();
		System.out.println(s + "w3 = " + w3);
	}
}/*Output:
Worm constructor: 6
Worm constructor: 5
Worm constructor: 4
Worm constructor: 3
Worm constructor: 2
Worm constructor: 1
w = :a(853):b(119):c(802):d(788):e(199):f(881)
Worm storage
w2 = :a(853):b(119):c(802):d(788):e(199):f(881)
Worm storage
w3 = :a(853):b(119):c(802):d(788):e(199):f(881)
*///
```
更有趣的是，Worm内的Data对象数组是用随机数初始化的（这样就不用怀疑编译器保留了某种原始信息了）。以上程序中的操作看起来较为复杂，从而加大了对象序列化的难度。
然而，真正的序列化过程却是非常简单的。一旦从另外某个流创建了ObjectOutputStream，writeObject()方法就会自动将对象序列化。注意也可以为一个String调用writeObject()。
也可以用与DataOutputStream相同的方法写入所有基本数据类型（它们具有同样的接口）。

上面的程序中，一个读写的是文件，另一个读写的是字节数组（ByteArray）。可利用序列化将对象读写到任何DataInputStream或者DataOutputStream中，甚至包括网络。

注意在对一个Serializable对象进行还原的过程中，没有调用任何构造器，包括默认构造器。整个对象都是通过从InputStream中取得的数据恢复而来的。

**练习27：（1）创建一个Serializable类，它包含一个对第二个Serializable类的对象的引用。创建你的类的实例，将其序列化到硬盘上，然后恢复它，并验证这个过程可以正确地工作。**

**答案请戳:point_right:[这里](solutions/Ex27.md)**

## 寻找类
将一个对象从它的序列化状态中恢复出来，有哪些工作是必须的呢？举个例子，假如我们将一个对象序列化，并通过网络将其作为文件送达给另一台计算机；
那么，另一个台计算机上的程序可以只利用该文件内容来还原这个对象吗？

回答这个问题的最好办法就是做一个实验。下面的Alien.java文件位于本章的io子目录下：
```java
// A serializable class
package io;
import java.io.*;

public class Alien implements Serializable {}
```
而用于创建和序列化一个Alien对象的文件也位于相同的目录下：
```java
// Create a serialized output file.
package io;
import java.io.*;

public class FreezeAlien {

	public static void main(String[] args) throws Exception {
        ObjectOutputStream out = new ObjectOutputStream(
        		new FileOutputStream("./src/io/X.file"));
        Alien quellek = new Alien();
        out.writeObject(quellek);
        out.close();
	}

}
```
这个程序不但能捕获和处理异常，而且将异常抛出到main()方法之外，以便通过控制台产生报告。一旦该程序被编译和运行，它就会在io目录下产生一个名为X.file的文件。
以下代码位于一个名为xfiles的子目录下：
```java
package io.xfiles;
// Try to recover a serialized file without the
// class of object that's stored in that file.
import java.io.*;

public class ThawAlien {

	public static void main(String[] args) throws Exception {
        ObjectInputStream in = new ObjectInputStream(
        		new FileInputStream(new File("./src/io", "X.file")));
        Object mystery = in.readObject();
        System.out.println(mystery.getClass());
	}

}/*Output:
class io.Alien
*///
```
打开文件和读取mystery对象中的内容都需要Alien的Class对象；但是Java虚拟机并没有找到Alien.class（除非它正好在类路径Classpath中，而本例却不在类路径之内）。
如果不是因为X.file文件中存在一个Alien对象的序列化字节，我们就会得到一个ClassNotFountException异常。所以我们通过对象的反序列化，保证了Java虚拟机得到了相关的.class文件。

## 序列化的控制
有时我们因为一些特殊的需要，例如，出于特殊的安全考虑，你不希望对象的某一部分被序列化；或者一个对象被还原以后，某子对象需要重新创建，从而不必将该子对象序列化。

在这些特殊情况下，可通过实现**Externalizable**接口——替代实现**Serializable**接口——来对序列化过程进行控制。这个Externalizable接口继承了Serializable接口，
同时增添了两个方法：writeExternal()和readExternal()。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊操作。

下面这个例子展示了Exernalizable接口方法的简单实现。注意Blip1和Blip2的细微差别：
```java
package io;
import java.io.*;

class Blip1 implements Externalizable {
	public Blip1() {
		System.out.println("Blip1 constructor");
	}
	public void writeExternal(ObjectOutput out) throws IOException {
		System.out.println("Blip1.writeExternal");
	}
	public void readExternal(ObjectInput in) 
			throws IOException, ClassNotFoundException {
		System.out.println("Blip1.readExternal");
	}
}

class Blip2 implements Externalizable {
	Blip2() {
		System.out.println("Blip2 constructor");
	}
	public void writeExternal(ObjectOutput out) throws IOException {
		System.out.println("Blip2.writeExternal");
	}
	public void readExternal(ObjectInput in) 
			throws IOException, ClassNotFoundException {
		System.out.println("Blip2.readExternal");
	}
}

public class Blips {

	public static void main(String[] args) throws IOException, ClassNotFoundException {
        System.out.println("Constructing objects: ");
        Blip1 b1 = new Blip1();
        Blip2 b2 = new Blip2();
        ObjectOutputStream out = new ObjectOutputStream(
        		new FileOutputStream("./src/io/Blips.out"));
        System.out.println("Saving objects:");
        out.writeObject(b1);
        out.writeObject(b2);
        out.close();
        // Now get them back:
        ObjectInputStream in = new ObjectInputStream(
        		new FileInputStream("./src/io/Blips.out"));
        System.out.println("Recovering b1:");
        b1 = (Blip1)in.readObject();
        // OOPS! Throws an exception:
        //! System.out.println("Recovering b2:");
        //! b2 = (Blip2)in.readObject();
	}

}/*Output:
Constructing objects: 
Blip1 constructor
Blip2 constructor
Saving objects:
Blip1.writeExternal
Blip2.writeExternal
Recovering b1:
Blip1 constructor
Blip1.readExternal
*///
```
上例中没有恢复Blip2对象，因为那样做会导致一个异常。Blip1的构造器是“公共的”（public），Blip2的构造器却不是，这就是导致异常的原因。如果将Blip2的构造器变成public的，
就不会再抛出异常了。

对于Serializable对象，对象完全以它存储的二进制位来构造，而不会调用构造器。而对于一个Externalizable对象，所有普通的默认构造器都会先被调用（包括在字段定义时的初始化），
然后才调用readExternal()。必须注意一点——**所有默认的构造器都会被调用，才能使Exernalizable对象产生正确的行为。**

下面这个例子示范了如何完整保存和恢复一个Externalizable对象：
```java
package io;
import java.io.*;

public class Blip3 implements Externalizable {
    protected int i;
    protected String s;
    public Blip3() {
    	System.out.println("Blip3 default constructor");
    	// i, s not initialized
    }
    public Blip3(int i, String s) {
    	System.out.println("Blip3(int i, String s)");
    	this.i = i;
    	this.s = s;
    	// i & s initialized only in non-default constructor.
    }
    public String toString() { return s + i; }
	@Override
	public void readExternal(ObjectInput in) 
			throws IOException, ClassNotFoundException {
		System.out.println("Blip3.readExternal");
		// You must do this:
		this.i = in.readInt();
		this.s = (String)in.readObject();
	}
	@Override
	public void writeExternal(ObjectOutput out) throws IOException {
		System.out.println("Blip3.writeExternal");
		// You must do this:
		out.writeInt(i);
		out.writeObject(s);
	}
	public static void main(String[] args) throws IOException, ClassNotFoundException {
        System.out.println("Constructing objects:");
        Blip3 b3 = new Blip3(47, "A String ");
        System.out.println(b3);
        ObjectOutputStream out = new ObjectOutputStream(
        		new FileOutputStream("./src/io/Blip3.out"));
        System.out.println("Saving object:");
        out.writeObject(b3);
        out.close();
        // Now get it back:
        ObjectInputStream in = new ObjectInputStream(
        		new FileInputStream("./src/io/Blip3.out"));
        System.out.println("Recovering object:");
        b3 = (Blip3)in.readObject();
		System.out.println(b3);
	}

}/*Output:
Constructing objects:
Blip3(int i, String s)
A String 47
Saving object:
Blip3.writeExternal
Recovering object:
Blip3 default constructor
Blip3.readExternal
A String 47
*///
```
其中，字段i和s是在第二个构造器中初始化的，而不是在默认构造器中被初始化的。这意味着我们必须在readExternal()方法中初始化它们，否则s就会是null，i就会为零。

我们如果从一个Externalizable对象继承，通常需要调用基类的writeExternal()和readExternal()来为基类组件提供恰当的存储和恢复功能。

因此，为了正常运行，我们不仅需要在writeExternal()方法中将来自对象的重要信息进行写入，还必须在readExternal()方法中恢复数据。起先，可能会有一点迷惑，
看起来好像是Externalizble对象的默认构造器自动地进行了存储和恢复操作。

**练习28：(2) 创建一个Ex28_BlipCheck.java文件，**
**复制类Blip2并重命名为Ex28_BlipCheck。复制Blips类并重命名为Blips2，**
**然后在Ex28_BlipCheck类中的main()方法中调用Blips2中的main()方法。删除Blips2中的//!标记，然后执行含有这几个错误行的程序。**
**接下来，注释掉Ex28_BlipCheck的默认构造器。执行并解释它可以运行的原因。注意，如果使用java命令行，编译后我们必须使用java io.Blips2执行程序，因为main()方法仍在Blips2类中。**
**必要时程序中Blips.out文件的路径也要做出相应的修改。**

**答案请戳:point_right:[这里](solutions/Ex28.md)**


**练习29：（2）注释掉Blip3.java中自“You must do this:” 开始的两行，运行之。解释结果，并说出该结果与不注释这两行所产生的结果不同的原因。**

**答案请戳:point_right:[这里](solutions/Ex29.md)**





