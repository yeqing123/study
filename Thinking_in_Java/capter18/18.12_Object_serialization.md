# 18.12 对象序列化

当你创建对象是，只要你需要，它就会一直存在，直到程序终止时为止。但是在某些情况下，如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。
这样，下次运行程序时，该对象将被重建并且拥有与程序上次运行时相同的信息。当然，你可以通过将信息写入文件或数据库来达到相同的效果，但是在万物皆对象的精神中，
如果能将一个对象声明为“持久性”的，并为我们处理掉所有细节，那将会显得十分方便。

Java的***对象序列化***把那些实现了***Serializable***接口的对象转换成了一个字节序列，并可以在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可以通过网络进行；
这意味着序列化机制能自动弥补不同操作系统之间的差异。

就其本身来说，对象的序列化是非常有趣的，因为利用它可以实现***轻量级持久性（lightwight persistence）***。“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行；
它可以生存在程序的调用之间。说它是“轻量级”的，是因为不能用类似 **“persistence”** （持久）的关键字来简单地定义一个对象，并让系统自动维护其他细节问题（将来或许会实现）。
相反，对象必须在程序中显示地进行序列化（serialize）和反序列化（deserialize）。如果需要一个更严格的持久性机制，可以考虑像Hibernate之类的工具（参见http://hibernate.sourceforge.net）。

对象序列化的概念加入到编程语言中，主要是为了支持两种特性。一是Java的***远程方法调用(Remote Method Invocation, RMI)*** ，它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。
当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。在《Thinking in Enterprise Java》中有对RMI的具体讨论。二是，对于Java Beans来说，对象的序列化也是必需的（可参见第14章）。
使用一个Bean时，一般情况下是设计阶段对它的状态信息进行设置。这种状态信息必须保存下来，并在程序启动时进行后期恢复；这种具体工作就是由对象序列化完成的。

只要对象实现了**Serializable**接口（该接口仅仅是一个标记接口，没有任何方法），对象的序列化处理就会非常简单。当序列化的概念被加入到Java语言中时，许多标准库类都发生了改变，
以便具备序列化特性——其中包括所有基本数据类型的封装器、所有容器类以及许多其他的东西。甚至Class对象也可以被序列化。

要序列化一个对象，首先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内。这时，只需调用writeObject()即可将对象序列化，
并将其发送给OutputStream(对象化序列是基于字节的，因此需使用InputStream和OutputStream继承层次结构)。要反向进行该过程（即将一个序列还原为一个对象），
需要将一个InputStream封装在ObjectInputStream内，然后调用readObject()方法即可。最后我们会获得一个引用，它指向一个向上转型后的Object对象，因此必须向下转型为我们想要的对象。

对象序列化特别“聪明”的一个地方是它不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象；并且还可以对对象内包含的每个这样的引用进行追踪，以此类推。
这种情况有时被称为“对象网”，单个对象可与之建立连接，而且它还包含了对象的引用数组以及成员对象。如果必须保持一个自己的对象序列化机制，那么维护那些可追踪到所有连接的代码可能会显得非常麻烦。
然而，Java的对象序列化似乎找不出什么缺点，所以请尽量不要自己动手，让它用优化的算法自动维护整个对象网。下面这个例子通过对连接的对象生成一个worm(蠕虫)对象序列化机制进行测试。
每个对象都与worm中的下一段连接，同时又与属于不同类的对象（Data）引用数组连接：

