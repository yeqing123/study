# 18.12 对象序列化

当你创建对象是，只要你需要，它就会一直存在，直到程序终止时为止。但是在某些情况下，如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。
这样，下次运行程序时，该对象将被重建并且拥有与程序上次运行时相同的信息。当然，你可以通过将信息写入文件或数据库来达到相同的效果，但是在万物皆对象的精神中，
如果能将一个对象声明为“持久性”的，并为我们处理掉所有细节，那将会显得十分方便。

Java的***对象序列化***把那些实现了***Serializable***接口的对象转换成了一个字节序列，并可以在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可以通过网络进行；
这意味着序列化机制能自动弥补不同操作系统之间的差异。

就其本身来说，对象的序列化是非常有趣的，因为利用它可以实现***轻量级持久性（lightwight persistence）***。“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行；
它可以生存在程序的调用之间。说它是“轻量级”的，是因为不能用类似 **“persistence”** （持久）的关键字来简单地定义一个对象，并让系统自动维护其他细节问题（将来或许会实现）。
相反，对象必须在程序中显示地进行序列化（serialize）和反序列化（deserialize）。如果需要一个更严格的持久性机制，可以考虑像Hibernate之类的工具（参见http://hibernate.sourceforge.net）。

对象序列化的概念加入到编程语言中，主要是为了支持两种特性。一是Java的***远程方法调用(Remote Method Invocation, RMI)*** ，它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。
当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。在《Thinking in Enterprise Java》中有对RMI的具体讨论。二是，对于Java Beans来说，对象的序列化也是必需的（可参见第14章）。
使用一个Bean时，一般情况下是设计阶段对它的状态信息进行设置。这种状态信息必须保存下来，并在程序启动时进行后期恢复；这种具体工作就是由对象序列化完成的。

只要对象实现了**Serializable**接口（该接口仅仅是一个标记接口，没有任何方法），对象的序列化处理就会非常简单。当序列化的概念被加入到Java语言中时，许多标准库类都发生了改变，
以便具备序列化特性——其中包括所有基本数据类型的封装器、所有容器类以及许多其他的东西。甚至Class对象也可以被序列化。

要序列化一个对象，首先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内。这时，只需调用writeObject()即可将对象序列化，
并将其发送给OutputStream(对象化序列是基于字节的，因此需使用InputStream和OutputStream继承层次结构)。要反向进行该过程（即将一个序列还原为一个对象），
需要将一个InputStream封装在ObjectInputStream内，然后调用readObject()方法即可。最后我们会获得一个引用，它指向一个向上转型后的Object对象，因此必须向下转型为我们想要的对象。

对象序列化特别“聪明”的一个地方是它不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象；并且还可以对对象内包含的每个这样的引用进行追踪，以此类推。
这种情况有时被称为“对象网”，单个对象可与之建立连接，而且它还包含了对象的引用数组以及成员对象。如果必须保持一个自己的对象序列化机制，那么维护那些可追踪到所有连接的代码可能会显得非常麻烦。
然而，Java的对象序列化似乎找不出什么缺点，所以请尽量不要自己动手，让它用优化的算法自动维护整个对象网。下面这个例子通过对连接的对象生成一个worm(蠕虫)对象序列化机制进行测试。
每个对象都与worm中的下一段连接，同时又与属于不同类的对象（Data）引用数组连接：
```java
package io;
import java.io.*;
import java.util.*;

class Data implements Serializable {
	private int n;
	public Data(int n) { this.n = n; }
	public String toString() { return Integer.toString(n); }
}

public class Worm implements Serializable {
	private static Random rand = new Random(47);
	private char c;
	private Data[] d = {
			new Data(rand.nextInt(10)),
			new Data(rand.nextInt(10)),
			new Data(rand.nextInt(10))
	};
	private Worm next;
	// Value of i == number of segments
	public Worm(int i, char x) {
		System.out.println("Worm constructor: " + i);
		this.c = x;
		if(--i > 0)
		    this.next = new Worm(i, (char)(x + 1));
	}
	public Worm() {
		System.out.println("Default constructor");
	}
	public String toString() {
		StringBuilder result = new StringBuilder(":");
		result.append(c);
		result.append("(");
		for(Data dat : d)
			result.append(dat);
		result.append(")");
		if(next != null)
		    result.append(next);
		return result.toString();
	}
	public static void main(String[] args) throws ClassNotFoundException, IOException {
		ObjectOutputStream out = new ObjectOutputStream(
				new FileOutputStream("./src/io/worm.out"));
		Worm w = new Worm(6, 'a');
		System.out.println("w = " + w);
		out.writeObject("Worm storage\n");
		out.writeObject(w);
		out.close();   // Also flushes output
		ObjectInputStream in = new ObjectInputStream(
				new FileInputStream("./src/io/worm.out"));
		String s = (String)in.readObject();
		Worm w2 = (Worm)in.readObject();
		System.out.println(s + "w2 = " + w2);
		ByteArrayOutputStream bout = new ByteArrayOutputStream();
		ObjectOutputStream out2 = new ObjectOutputStream(bout);
		out2.writeObject("Worm storage\n");
		out2.writeObject(w);
		out2.flush();
		ObjectInputStream in2 = new ObjectInputStream(
				new ByteArrayInputStream(bout.toByteArray()));
		s = (String)in2.readObject();
		Worm w3 = (Worm)in2.readObject();
		System.out.println(s + "w3 = " + w3);
	}
}/*Output:
Worm constructor: 6
Worm constructor: 5
Worm constructor: 4
Worm constructor: 3
Worm constructor: 2
Worm constructor: 1
w = :a(853):b(119):c(802):d(788):e(199):f(881)
Worm storage
w2 = :a(853):b(119):c(802):d(788):e(199):f(881)
Worm storage
w3 = :a(853):b(119):c(802):d(788):e(199):f(881)
*///
```
更有趣的是，Worm内的Data对象数组是用随机数初始化的（这样就不用怀疑编译器保留了某种原始信息了）。以上程序中的操作看起来较为复杂，从而加大了对象序列化的难度。
然而，真正的序列化过程却是非常简单的。一旦从另外某个流创建了ObjectOutputStream，writeObject()方法就会自动将对象序列化。注意也可以为一个String调用writeObject()。
也可以用与DataOutputStream相同的方法写入所有基本数据类型（它们具有同样的接口）。

上面的程序中，一个读写的是文件，另一个读写的是字节数组（ByteArray）。可利用序列化将对象读写到任何DataInputStream或者DataOutputStream中，甚至包括网络。

注意在对一个Serializable对象进行还原的过程中，没有调用任何构造器，包括默认构造器。整个对象都是通过从InputStream中取得的数据恢复而来的。

**练习27：（1）创建一个Serializable类，它包含一个对第二个Serializable类的对象的引用。创建你的类的实例，将其序列化到硬盘上，然后恢复它，并验证这个过程可以正确地工作。**

**答案请戳:point_right:[这里](solutions/Ex27.md)**

## 寻找类
将一个对象从它的序列化状态中恢复出来，有哪些工作是必须的呢？举个例子，假如我们将一个对象序列化，并通过网络将其作为文件送达给另一台计算机；
那么，另一个台计算机上的程序可以只利用该文件内容来还原这个对象吗？

回答这个问题的最好办法就是做一个实验。下面的Alien.java文件位于本章的io子目录下：
```java
// A serializable class
package io;
import java.io.*;

public class Alien implements Serializable {}
```
而用于创建和序列化一个Alien对象的文件也位于相同的目录下：
```java
// Create a serialized output file.
package io;
import java.io.*;

public class FreezeAlien {

	public static void main(String[] args) throws Exception {
        ObjectOutputStream out = new ObjectOutputStream(
        		new FileOutputStream("./src/io/X.file"));
        Alien quellek = new Alien();
        out.writeObject(quellek);
        out.close();
	}

}
```
这个程序不但能捕获和处理异常，而且将异常抛出到main()方法之外，以便通过控制台产生报告。一旦该程序被编译和运行，它就会在io目录下产生一个名为X.file的文件。
以下代码位于一个名为xfiles的子目录下：
```java
package io.xfiles;
// Try to recover a serialized file without the
// class of object that's stored in that file.
import java.io.*;

public class ThawAlien {

	public static void main(String[] args) throws Exception {
        ObjectInputStream in = new ObjectInputStream(
        		new FileInputStream(new File("./src/io", "X.file")));
        Object mystery = in.readObject();
        System.out.println(mystery.getClass());
	}

}/*Output:
class io.Alien
*///
```
打开文件和读取mystery对象中的内容都需要Alien的Class对象；但是Java虚拟机并没有找到Alien.class（除非它正好在类路径Classpath中，而本例却不在类路径之内）。
如果不是因为X.file文件中存在一个Alien对象的序列化字节，我们就会得到一个ClassNotFountException异常。所以我们通过对象的反序列化，保证了Java虚拟机得到了相关的.class文件。



