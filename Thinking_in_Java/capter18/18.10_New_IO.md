# 18.10 新I/O
JDK 1.4的Java.nio.*包中引入了新的Java I/O类库，其目的在于提高速度。实际上，旧的I/O包已经使用nio重新实现过了，以便充分利用这种速度优势，因此，即使我们不显示地用nio编写代码，
也能从中受益。速度的提高在文件I/O和网络I/O中都有可能发生，我们这里只研究前者。

速度的提高来自于所使用的结构更接近于操作系统执行I/O的方式：**通道（cannel）**和**缓冲器（buffer）**。在从通道读取或写入数据时，我们并没有直接和通道交互；
我们只是和缓冲器交互，并把缓冲器派送到通道。通道要么从缓冲器获得数据，要么向缓冲器发送数据。

唯一直接与通道交互的缓冲器是ByteBuffer——也就是说，我们只能向缓冲器中存储未加工过的字节。java.nio.ByteBuffer类是一个相当基础的类：
通过告知分配多少存储空间来创建一个ByteBuffer对象，并且还有一些方法集，用于以原始字节或基本数据类型的形式输出和读取数据。
但是，它没有办法输出或读取对象，即使是字符串对象也不行。这种处理虽然很低级，但正好与大多数操作系统中的处理方式一致。

旧I/O类库中有三个类被修改了，用以产生一个FileChannel对象。它们是：**FileInputStream、FileOutputStream**以及用于即读又写的**RandomAccessFile**。
注意这些都是字节操作流，与低层的nio性质一致。Reader和Writer这种字符模式类不能用于产生通道；但是，java.nio.channels.Channels类提供了实用方法，用于在通道中产生Reader和Writer。

下面的简单实例演示了上面三种类型的流，用以产生“可写的、可读可写的以及可读的”三条通道。
```java
package io;
import java.nio.*;
import java.nio.channels.*;
import java.io.*;

public class GetChannel {
    private static final int BSIZE = 1024;
	@SuppressWarnings("resource")
	public static void main(String[] args) throws IOException {
	    // 生成一条输出通道，用于向文件写入
		FileChannel fc = new FileOutputStream("./src/io/data.txt").getChannel();
	    // 将数据放入缓冲器，并利用通道写入文件
		fc.write(ByteBuffer.wrap("Some text".getBytes()));
	    fc.close();
	    // 向文件的末尾追加内容
	    fc = new RandomAccessFile("./src/io/data.txt", "rw").getChannel();
	    // 移动到文件末尾
	    fc.position(fc.size());
	    // 利用通道将数据写入文件
	    fc.write(ByteBuffer.wrap(" Some more text".getBytes()));
	    fc.close();
	    // 生成一条输入通道，用于读取文件
	    fc = new FileInputStream("./src/io/data.txt").getChannel();
	    // 为缓冲器分配大小
	    ByteBuffer buff = ByteBuffer.allocate(BSIZE);
	    fc.read(buff);
	    // flip()方法表示缓冲器已准备就绪，可以读取数据
	    buff.flip();
	    while(buff.hasRemaining())
	    	System.out.print((char)buff.get());
	}

}/*Output:
Some text Some more text
*///
```
getChannel()方法会产生一个FileChannel。通道是一种相当基础的东西：可以向它传送用于读写的ByteBuffer，并且可以锁定文件的某些区域用于独占式访问（稍后会讲述）。

将字节存放与ByteBuffer的方式之一是：使用“put”方法直接对它们进行填充，填入一个或多个字节，或者基本数据类型的值。也可以使用warp()方法将已存在的字节数组“包装”到ByteBuffer中。一旦如此，就不再复制底层的数组，而是把它作为所产生的ByteBuffer的存储器，我们称之为“数组支持的ByteBuffer”。

使用RandomAccessFile打开的文件，可以在文件内随处移动FileChannel。在这里，我们把它移到最后，以便附加其他的写操作。

对于只读访问，我们***必须***显式地使用静态的allocate()方法来分配一个新的缓冲区。nio的目标就是快速移动大量数据，因此ByteBuffer的大小就显得尤为重要——实际上，
这里使用的1K可能比我们通常要使用的小一点（必须通过实际运行应用程序来找到最佳尺寸）。

甚至达到更高的速度也是有可能的，方法就是使用allocateDirect()而不是allocate()，以产生一个与操作系统有更高耦合性的“直接缓冲器”。
但是，这种分配的开支会更大，并且具体实现也随操作系统的不同而不同，因此必须再次实际运行应用程序来查看“直接缓冲器”是否可以使我们获得速度上的优势。

一旦调用了FileChannel的read()方法向ByteBuffer中存储了字节，就必须调用缓冲器上的flip()，让它做好准备以便别人读取这些字节（虽然这样做似乎显得有点拙劣，但却适用于获取最大速度）。
如果我们打算继续调用read()向缓冲器中存储新的字节，就必须的调用clear()来对其进行清理。这在下面简单的文件复制程序中可以看到：
```java
// Copying a file using channels and buffers
// {Args: ./src/io/ChannelCoty.java test.txt}
package io;
import java.nio.*;
import java.nio.channels.*;
import java.io.*;

public class ChannelCopy {
    private static final int BSIZE = 1024;
	@SuppressWarnings("resource")
	public static void main(String[] args) throws IOException {
        if(args.length != 2) {
        	System.err.println("Uages: sourcefile destfile");
        	System.exit(1);
        }
        FileChannel in = new FileInputStream(args[0]).getChannel();
        FileChannel out = new FileOutputStream(args[1]).getChannel();
        ByteBuffer buff = ByteBuffer.allocate(BSIZE);
        while(in.read(buff) != -1) {
        	buff.flip();    // Prepare for writing
        	out.write(buff);
        	buff.clear();   // Prepare for reading
        }
	}

}
```
可以看到，我们获取了两个FileChannel，一个用于从源文件中读取数据，另一个用于向目标文件中写入数据。当FileChannel.read()返回-1时（一个分界符，毋庸置疑，它源于Unix和C），
表示我们已经到达了输入的末尾。每次调用read()之后都要调用flip()方法让缓冲器做好准备，以便可以由write()提取。write()操作之后，信息仍在缓冲器中，
接着clear()操作则对所有的内部指针重新安排，以便缓冲器在下一次read()操作期间能够接受新的数据。

然而，上面那个程序并不是处理此类操作的理想方式。特殊方法transferTo()和transferFrom()则允许我们将一个通道和另一个通道直接相连：
```java
// Using special method to connect two channels.
// {Args: ./src/io/ChannelConnect.java ./src/io/test.txt}
package io;
import java.nio.channels.*;
import java.io.*;

public class ChannelConnect {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws IOException {
		if(args.length != 2) {
			System.err.println("Uages: sourcefile deskfile");
			System.exit(1);
		}
        FileChannel 
            in = new FileInputStream(args[0]).getChannel(),
            out = new FileOutputStream(args[1]).getChannel();
        in.transferTo(0, in.size(), out);
        // or
//        out.transferFrom(in, 0, in.size());
	}

}
```
虽然我们并不是经常所这类事情，但是了解这一点还是有好处的。

## 转换数据
在GetChannel.java程序中，为了输出文件中的信息，我们***必须***每次只读取一个字节的数据，然后让其强制转换成char类型。这种方法似乎有点原始——如果查看一下java.nio.CharBuffer类，
将会发现有一个toString()方法是这样定义的：“返回一个包含缓冲器中所有字符的字符串”，并且ByteBuffer有一个asCharBuffer()方法可以获得CharBuffer对象，那么为什么不用它呢？
从下面输出语句的第一行可见，这种方法并不能解决问题：
```java
package io;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.Charset;
import java.io.*;

public class BufferToText {
    private static final int BSIZE = 1024;
	@SuppressWarnings("resource")
	public static void main(String[] args) throws IOException {
		FileChannel fc = new FileOutputStream("./src/io/data.txt").getChannel();
		fc.write(ByteBuffer.wrap("Some text".getBytes()));
		fc.close();
		ByteBuffer buff = ByteBuffer.allocate(BSIZE);
		fc = new FileInputStream("./src/io/data.txt").getChannel();
		fc.read(buff);
		buff.flip();
		// Doesn't work
		System.out.println(buff.asCharBuffer());
		buff.rewind();
		// Decoding using this system's default Charset:
		String encoding = System.getProperty("file.encoding");
		System.out.println("Decoding using " + encoding + ": "
		    + Charset.forName(encoding).decode(buff));
		// Or, encode when data is written a file:
		fc = new FileOutputStream("./src/io/data2.txt").getChannel();
		fc.write(ByteBuffer.wrap("Some text".getBytes("UTF-16BE")));
		fc.close();
		// Now try reading again:
		fc = new FileInputStream("./src/io/data2.txt").getChannel();
		buff.clear();
		fc.read(buff);
		buff.flip();
		System.out.println(buff.asCharBuffer());
		// Use a CharBuffer to write through:
		fc = new FileOutputStream("./src/io/data2.txt").getChannel();
		buff = ByteBuffer.allocate(24);   // More than needed
		buff.asCharBuffer().put("Some text");
		fc.write(buff);
		fc.close();
		// Read and display:
		fc = new FileInputStream("./src/io/data2.txt").getChannel();
		buff.clear();
		fc.read(buff);
		buff.flip();
		System.out.println(buff.asCharBuffer());
	}

}/*Output:
卯浥⁴數
Decoding using UTF-8: Some text
Some text
Some text
*///
```
缓冲器容纳的是普通的字节，为了把它们转换成字符，我们要么在输入它们的时候对其进行***编码***（这样，它们输出时才有意义），要么在将其从缓冲器中输出时对它们进行***编码***。
可以使用java.nio.charset.Charset类实现这些功能，该类提供了把数据编码成多种不同类型的字符集的工具：
```java
// Display Charsets and aliases
package io;
import java.nio.charset.Charset;
import java.util.*;


public class AvailableCharSets {

	public static void main(String[] args) {
		SortedMap<String, Charset> charSets = Charset.availableCharsets();
		Iterator<String> it = charSets.keySet().iterator();
		while(it.hasNext()) {
			String csName = it.next();
			System.out.print(csName);
			Iterator<String> aliases = charSets.get(csName).aliases().iterator();
			if(aliases.hasNext())
			    System.out.print(": ");
			while(aliases.hasNext()) {
				System.out.print(aliases.next());
				if(aliases.hasNext())
					System.out.print(", ");
			}
			System.out.println();
		}
	}

}/*Output:
Big5: csBig5
Big5-HKSCS: big5-hkscs, big5hk, Big5_HKSCS, big5hkscs
CESU-8: CESU8, csCESU-8
EUC-JP: csEUCPkdFmtjapanese, x-euc-jp, eucjis, Extended_UNIX_Code_Packed_Format_for_Japanese, euc_jp, eucjp, x-eucjp
EUC-KR: ksc5601-1987, csEUCKR, ksc5601_1987, ksc5601, 5601, euc_kr, ksc_5601, ks_c_5601-1987, euckr
GB18030: gb18030-2000
GB2312: gb2312, euc-cn, x-EUC-CN, euccn, EUC_CN, gb2312-80, gb2312-1980
GBK: CP936, windows-936
...
*///
```
让我们返回到BufferToText.java，如果我们对缓冲器调用rewind()方法（调用该方法是为了返回到数据开始部分），接着使用平台的默认字符集对数据进行decode(),
那么作为结果的CharBuffer可以很好地输出打印到控制台。可以使用System.getProperty("file.encoding")发现默认字符集，它会产生代表字符集名称的字符串。
把该字符串传送给Charset.forName()用以产生Charset对象，可以用它对字符串进行解码。

另一选择是在读文件时，使用能够产生可打印输出的字符集进行encode()，正如在BufferToText.java中第3部分所看到的那样。这里，UTF-16BE可以把文本写到文件中，当读取时，
我们只需要把它转换成CharBuffer，就会产生所期望的文本。

最后，让我们看看若是通过CharBuffer向ByteBuffer写入，会发生什么情况（后面将会深入了解）。注意我们为ByteBuffer分配了24个字节。既然一个字符需要2个字节，
那么这个ByteBuffer足可以容纳12个字符，但是"Some text"只有9个字符，剩余的内容为零的字节仍会出现在由toString()所产生的CharBuffer的表示中，我们可以在输出结果中看到。

**练习23：（6）创建并测试一个实用方法，使其可以打印出CharBuffer中的内容，直到字符不能再打印为止。**

**答案请戳:point_right:[这里](solutions/Ex23.md)**



 