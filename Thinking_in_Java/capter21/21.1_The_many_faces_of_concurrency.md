# 21.1 并发的多面性

- [一、更快的执行](#一、更快的执行)
- [二、改进代码设计](#二、改进代码设计)

并发编程令人困惑的一个主要原因是：使用并发时需要解决的问题有多个，而实现并发的方式也有多种，并且在这两者之间没有明显的映射关系（而且通常只具有模糊的界限）。
因此，你必须理解所有这些问题和特例，以便有效地使用并发。

用并发解决的问题大体上可以分为：“速度”和“设计可管理性”两种。

---

## 一、更快的执行
速度问题初听起来很简单：如果你想要一个程序运行得更快，那么可以将其断开为多个片段，在单独的处理器上运行每个片段。并发是用于多处理器编程的基本工具。
为了使程序运行得更快，你必须学习如何利用这些额外的处理器，而这正是并发赋予你的能力。

如果你有一台多处理器的机器，那么就可以在这些处理器之间分布多个任务，从而可以极大地提高吞吐量。这是使用强有力的多处理器Web服务器的常见情况，在为每个请求分配一个线程的程序中，
它可以将大量的用户请求分布到多个CPU上。

但是，并发通常是用作提高运行在**单处理器**上的程序的性能。

在单处理器上用得着使用并发吗？在单处理器上运行并发程序的开销通常比该程序的所有部分都顺序执行的开销大，因为其中增加了所谓**上下文切换**的代价。
所以，从表面上看，将程序的所有部分当做单个任务运行好像是开销更小一点，并且可以节省上下文切换的代价。

使这个问题变得有些不同的是**阻塞**。如果程序中的某个任务因为该程序控制范围之外的某个条件（通常是I/O）而导致不能继续执行，那么我们就说这个任务或线程被**阻塞**了。
如果没有并发，则整个任务都将停止下来，直至外部条件发生变化。但是，如果使用并发来编写程序，那么当一个任务阻塞时，程序中的其他任务还可以继续运行，因此这个程序可以保持继续向前执行。
事实上，从性能的角度看，如果没有任务会阻塞，那么在单处理器上使用并发就没有任何意义。

在单处理器系统中的性能提高的常见示例是**事件驱动的编程**。实际上，使用并发最吸引人的一个原因就是要产生具有可响应的用户界面。考虑这样一个程序，它因为要执行某个长期运行的操作，
所以用户在界面上的输入将会被忽略，从而成为一个不可响应的程序。如果不使用并发，则产生可响应用户界面的唯一方式就是所有的任务都周期性第检查用户输入。
通过创建单独的执行线程来响应用户的输入，即使这个线程在大多数时间都是阻塞的，但是程序也可以保证具有一定的可响应性。

在单处理器系统上使用传统的方法连续执行某个操作，同时还要返回对程序其余部分的控制。事实上，这听起来就好像是不可能的事，因为CPU同时要处于两处一样，
但是这完全是并发造成的一种错觉（在多处理器系统中，这就不只是一种幻觉了）。

实现并发最直接的方式是在操作系统级别使用**进程**。*进程是运行在它自己的地址空间内的自包容的程序*。多任务操作系统可以通过周期性第将CPU从一个进程切换到另一个进程，
来实现同时运行多个进程（程序）。进程总是很吸引人的，因为操作系统通常会将进程互相隔离开，因此它们不会彼此干涉，这使得用进程编程相对容易一些。
与此相反，像Java所使用的并发系统会共享诸如内存和I/O这样的资源，因此编写多线程程序最基本的困难在于在协调不同线程驱动的任务之间对这些资源的使用，
以使得这些资源不会同时被多个任务访问。

使用并发的理想状态是，每个任务都作为进程在其自己的地址空间中执行，因此任务之间根本不可能互相干涉。更重要的是，对进城来说，它们之间没有任何彼此通信的需要，因为它们都是完全独立的。
同时操作系统会负责进程切换和执行的所有细节，因此，不会有任何风险，你可以获得更快的程序，并且完全免费。因此，有些人提倡将进程作为唯一合理的并发方式，但遗憾的是，
对进程通常会有数量和开销的限制，以避免它们在不同的并发系统之间的可应用性。

某些编程语言被设计为可以将并发任务***彼此隔离***，这些语言通常被称为**函数型语言**，其中每个函数调用都不会产生任何副作用（并因此而不能干涉其他函数），并因此可以当作独立的任务来驱动。
Erlang就是这样的语言，它包含针对任务之间彼此通信的安全机制。如果你发现程序中某个部分必须大量使用并发，并且你在试图构建这个部分时碰到了过多的问题，
那么你可以考虑使用像Erlang这类专门的并发语言来创建这个部分。

Java采取了更加传统的方式，在顺序型语言的基础上提供对线程的支持。与在多任务操作系统上分叉外部进程不同，线程机制是在由执行程序表示的单一进程中创建多个任务。
这种方式产生的好处是操作系统的透明性（即与操作系统无关），这对Java的宗旨：“编写一次，到处运行”而言，是一个重要的设计目标。

## 二、改进代码设计
在单CPU机器上使用多任务的程序在任意时刻仍旧只在执行一项工作，因此从理论上讲，我们可以不用多任务而编写出相同的程序。但是，并发提供了一个重要的组织结构上的好处，
使你的程序设计可以极大地简化。某些类型的问题，例如仿真，没有并发的支持就很难解决。

完整的仿真可能涉及非常大量的任务，这与仿真中的每个元素都可以独立动作这一事实相对应。多线程系统对可用的线程数量的限制他通常都会是一个相对较小的数字，有事就是数十或数百这样的数量级。
在Java中，通常要假定你不会获得足够的线程，从而使得可以为大型仿真中的每个元素都提供一个线程。这个数字依赖不同的平台，或者是Java的版本。

解决这个问题的典型方式是使用**协作多线程**。Java的线程机制是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，
使得每个线程都会分配到数量合理的时间去驱动它的任务。在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识地在每个任务中插入某种类型的让步语句。
*协作式系统的优势是双重的：上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制*。当你处理大量的仿真元素时，这是一种理想的解决方案。
但是注意，某些协作式系统并未设计为可以在多个处理器之间分布任务，这可能会非常受限。

在另一个极端，当你用流行的消息系统工作时，由于消息系统涉及分布在整个网络中的多台独立的计算机，因此并发就会成为一种非常有用的模型，因为它是实际发生的模型。
即使你没有打算在眼前大量使用并发，理解并发也会很有用，因为你可以掌握基于消息机制的架构，这些架构在创建分布式系统时是更主要方式。

并发需要付出代价，包含复杂性代价，但是这些代价与在程序设计、资源负载均衡以及用户方便使用方面的改进相比，就显得微不足道了。通常，多线程使你能够创建更加松散耦合的设计，
否则，你的代码中各个部分都必须显示地关注那些通常可以由线程来处理的任务。

---

### [下一节：基本的线程机制](21.2_Basic_threading.md)
