# 21.2　基本的线程机制
- [一、定义任务](#一、定义任务)
- [二、Thread类](#二、thread类)
- [三、使用Executor](#三、使用executor)
- [四、从任务中产生返回值](#四、从任务中产生返回值)
- [五、休眠](#五、休眠)
- [六、优先级](#六、优先级)
- [七、让步](#七、让步)
- [八、后台线程](#八、后台线程)
- [九、编码的变体](#九、编码的变体)
- [十、术语](#十、术语)
- [十一、加入一个线程](#十一、加入一个线程)
- [十二、创建有响应的用户界面](#十二、创建有响应的用户界面)
- [十三、线程组](#十三、线程组)
- [十四、捕获异常](#十四、捕获异常)


并发编程使我们可以将程序划分为多个分离的、独立运行的*任务*。通过使用多线程机制，这些独立的任务（也被成为子任务）中的每一个都将由**执行线程**来驱动。
一个线程就是在进程中的一个单一的*顺序控制流*，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像由其自己的CPU一样。
其底层机制是切分CPU时间，但通常你不需要考虑它。

线程模型为编程带来了便利，它简化了对单一程序中同时交织在一起的多个操作的处理。每个任务都觉得自己在一直占用CPU，但事实上CPU时间是划分成片段分配给了所有的任务
（例外情况是程序确实运行在多个CPU之上）。线程的一大好处是可以使你从这个层次抽身出来，即代码不必知道它是运行在具有一个还是多个CPU的机器上。
所以，使用线程机制是一种建立透明的、可扩展的程序的方法，如果程序运行得太慢，为机器增添一个CPU就能很容易地加快程序的运行速度。多任务和多线程往往是使用多处理器系统的最合理方式。

---

## 一、定义任务
线程可以驱动任务，因此你需要一种描述任务的方式，这可以由Runnable接口来提供。要想定义任务，只需要实现Runnable接口并编写run()方法，使得该任务可以执行你的命令。
例如，下面的LiffOff任务将显示发射之前的倒计时：
```java
package concurrency;
// Demonstration of the Runnable interface.

public class LiftOff implements Runnable {
    protected int countDown = 10;     // Default
    private static int taskCount = 0;
    private final int id = taskCount++;
    public LiftOff() {}
    public LiftOff(int countDown) {
    	this.countDown = countDown;
    }
    public String status() {
    	return "#" + id + "(" + (countDown > 0 ? countDown : "Liftoff!") + "), ";
    }
    public void run() {
    	while(countDown > 0) {
    		System.out.println(status());
    		Thread.yield();
    	}
    }
}
```
任务的run()方法通常总会有某种形式的循环，使得任务一直运行下去直到不再需要，所以要设定跳出循环的条件（有一种选择是直接从run()返回）。
通常，run()被写成无限循环的形式，这就意味着，除非有某个条件使得run()终止，否则它将永远运行下去（在本章后面将会看到如何安全地终止线程）。

在run()中对静态方法Thread.yield()的调用是对**线程调度器**（Java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种*建议*，
它在声明：“我已经执行完声明周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机”。这完全是选择性的，但是这里使用它是因为它会在这些示例中产生更加有趣的输出：
你更有可能看到任务换进换出的证据。

在下面的实例中，这个任务的run()不是由另外创建的线程驱动的，它是在main()中直接调用的（实际上，这里仍旧使用了线程，即总是分配给main()的那个线程）：
```java
package concurrency;

public class MainThread {
	public static void main(String[] args) {
        LiftOff launch = new LiftOff();
        launch.run();
	}
} /*Output:
#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!), 
*///
```
当从Runnable接口导出一个类时，它必须具有run()方法，但是这个方法并无特殊之处——它不会产生任何内在的线程能力。要实现线程行为，你必须显式地将一个任务附着到指定的线程上。

## 二、Thread类
将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器，下面的示例展示了如何使用Thread来驱动LiftOff对象：
```java
package concurrency;

public class BasicThreads {
	public static void main(String[] args) {
        Thread t = new Thread(new LiftOff());
        t.start();
        System.out.println("Waiting for Liftoff");
	}
} /*Output:
Waiting for Liftoff
#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!), 
*///
```
Thread构造器只需要一个Runnable对象。调用Thread对象的start()方法为该线程执行必需的初始化操作，然后调用Runnable的run()方法，以便在这个有Thread构造的新线程中启动该任务。
尽管start()看起来是产生了一个对长期运行的方法的调用，但是从输出中可以看到，start()迅速地返回了，因为“Waiting for Liftoff”消息在倒计时完成之前就出现了。
***实际上，你产生的是对LiftOff.run()方法的调用，并且该方法是由不同的线程执行的，因此在run()方法还没有执行完成的时候，你仍旧可以执行main()线程中的其他操作（这种能力并不局限于main()方法，任何线程都可以启动另一个线程）。因此，程序会同时运行main()和LiftOff.run()两个方法，因为它们是执行在两个不同的线程中的任务***。

因此，你可以很容易地添加更多的线程来驱动更多的任务。下面，你可以看到所有任务彼此之间是如何互相呼应的：  
> 在本例中，是由单一的main()线程创建多个LiftOff线程，而如果是多个线程同时都在创建LiftOff线程，那么就有可能出现多个LiftOff拥有相同的id，在本章稍后你会了解到这是为什么。
```java
package concurrency;

public class MoreBasicThreads {
	public static void main(String[] args) {
        for(int i = 0; i < 5; i++) 
        	new Thread(new LiftOff()).start();
        System.out.println("Waiting for LiftOff");
	}
} /*Output:
Waiting for LiftOff
#4(9), #2(9), #2(8), #0(9), #3(9), #1(9), #3(8), #0(8), #0(7), #0(6), #0(5), #2(7), #4(8), 
#4(7), #2(6), #0(4), #0(3), #3(7), #1(8), #1(7), #1(6), #3(6), #0(2), #2(5), #4(6), #2(4), 
#2(3), #0(1), #0(Liftoff!), #3(5), #1(5), #2(2), #1(4), #2(1), #4(5), #2(Liftoff!), #1(3), 
#3(4), #1(2), #4(4), #1(1), #3(3), #1(Liftoff!), #4(3), #3(2), #4(2), #3(1), #4(1), #3(Liftoff!), #4(Liftoff!),
*///
```
输出说明不同任务的执行在线程被换进换出时混在了一起。这种交换是由线程调度器自动控制的。如果在你的机器上有多个处理器，线程调度器将会在这些处理器之间默默地分发线程。

这个程序一次运行的结果可能与另一次运行的结果不同，因为线程调度机制是非确定性的。事实上，在JDK的不同版本之间，这个简单程序的输出会产生巨大的差异。
较晚的JDK看起来会产生更好的时间切片行为，因此每个线程看起来都会获得更加正规的服务。通常，Sun并没有提及JDK的这些种类的行为变化，因此你不能依赖于任何线程行为的一致性。
最好的方式是在编写使用线程的代码时，尽可能地保守。

当main()创建Thread对象时，它并没有获得任何这些对象的引用。如果是使用普通的对象，这对于垃圾回收来说没有什么问题，但是在使用Thread对象时，情况就不同了。
每个Thread都“注册”了它自己，而且在它执行完任务（从其run()退出）并死亡之前，垃圾回收器无法清除它。你可以从输出中看到，这些任务确实运行到了最后，
因此，***一个线程会创建一个单独的执行线程，在对start()的调用完成之后，它仍旧会继续存在。***

**练习1：（2）实现一个Runnable。在run()内部打印一条启动消息，然后调用yield()。重复这个操作三次，然后从run()中返回。在该类的构造器中放置一条启动消息，并且放置一条在任务终止时的关闭消息。使用线程创建大量的这种任务并驱动它们。**

**答案请戳:point_right:[这里](solutions/Ex01.md)**

**练习2：（2）遵循generic/Fibonacci.java的形式，创建一个任务，它可以产生由n个斐波拉契数字组成的序列(可以使用数组)，其中n是通过任务的构造器而提供的。使用线程创建大量的这种任务并驱动它们。**

**答案请戳:point_right:[这里](solutions/Ex02.md)**

## 三、使用Executor
Java SE5的java.util.concurrent包中的**执行器***(Executor)。通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，通过Executor来启动线程比使用Thread的start方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免this逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用Executor在构造器中。Executor允许你管理异步任务的执行，而无须显式地管理线程的生命周期。因此Executor是在Java SE5/6之后，启动任务的优选方法。

我们可以使用Executor来代替在MoreBasicThreads.java中显示地创建Thread对象。ExecutorService是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法。
它知道如何构建恰当的上下文来执行Runnable对象。在下面的示例中，CachedTreadPool将为每个任务都创建一个线程。注意，ExecutorService对象是使用静态Executor方法创建的，
这个方法可以确定其Executor类型：
```java
package concurrency;
import java.util.concurrent.*;

public class CachedThreadPool {
	
	public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        for(int i = 0; i < 5; i++)
        	exec.execute(new LiftOff());
        exec.shutdown();
	}
	
} /*Output:
#2(9), #2(8), #2(7), #0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #3(9), #3(8), #3(7), #4(9), 
#4(8), #4(7), #1(9), #4(6), #3(6), #0(2), #2(6), #2(5), #0(1), #3(5), #4(5), #1(8), #1(7), #1(6), 
#4(4), #4(3), #4(2), #4(1), #4(Liftoff!), #3(4), #0(Liftoff!), #2(4), #2(3), #3(3), #3(2), #1(5), 
#1(4), #1(3), #1(2), #3(1), #2(2), #3(Liftoff!), #1(1), #1(Liftoff!), #2(1), #2(Liftoff!), 
*///
```
非常常见的情况是，单个的Executor被用来创建和管理系统中所有的任务。

调用ExecutorService的shutdown（）方法来平滑地关闭 ExecutorService，调用该方法后，将导致ExecutorService停止接受任何新的任务且等待已经提交的任务执行完成(已经提交的任务会分两类：一类是已经在执行的，另一类是还没有开始执行的)，当所有已经提交的任务执行完毕后将会关闭ExecutorService。因此我们一般用该接口来实现和管理多线程。

我们还可以将CahedThreadPool替换为不同类型的Executor。FixedTheadPool使用了有限的线程集来执行所提交的任务：
```java
package concurrency;
import java.util.concurrent.*;

public class FixedThreadPool {

	public static void main(String[] args) {
        ExecutorService exec = Executors.newFixedThreadPool(2);
        for(int i = 0; i < 5; i++)
        	exec.execute(new LiftOff());
        exec.shutdown();
	}

} /*Output:
#0(9), #1(9), #0(8), #1(8), #0(7), #1(7), #0(6), #1(6), #0(5), #1(5), #0(4), #1(4), #0(3), 
#1(3), #0(2), #1(2), #0(1), #1(1), #0(Liftoff!), #1(Liftoff!), #2(9), #2(8), #2(7), #3(9), 
#2(6), #3(8), #2(5), #3(7), #2(4), #3(6), #2(3), #3(5), #2(2), #3(4), #2(1), #3(3), 
#2(Liftoff!), #3(2), #4(9), #3(1), #4(8), #3(Liftoff!), #4(7), #4(6), #4(5), #4(4), 
#4(3), #4(2), #4(1), #4(Liftoff!), 
```
FixedThreadPool可控制线程最大并发数，超出的线程会在队列中等待。Executors.newFixedThreadPool(2);表示在线程池中保持二个线程可以同时执行，
但是注意，并不是说线程池中永远都是这两个线程，只是说可以同时存在的线程数，当某个线程执行结束后，会有新的线程进来。有了它，你就可以一次预先执行代价高昂的线程分配。
这可以节省时间，因为你不用为每个任务都固定地付出创建线程的开销。同时也不会滥用可获得的资源，因为FixedThreadPool使用的Thread对象的数量是有限的。

注意，在任何线程池中，现有线程在可能的情况下，都会被自动复用。

CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式会引发问题时，
你才需要切换到FixedThreadPool。

SingleThreadExecutor就像是线程数量为1的FixedThreadPool。如果调用Executors.newSingleThreadExecutor()方法，就会创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，
保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果向SingleThreadExecutor提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前结束，
所有的任务将使用相同的线程。在下面的示例中，你可以看到每个任务都是按照它们被提交的顺序，并且是在下一个任务开始之前完成的。因此，SingleThreadExecutor会序列化所有提交给它的任务，
并会维护它自己的（隐藏的）悬挂任务队列。
```java
package concurrency;
import java.util.concurrent.*;

public class SingleThreadExeuctor {

	public static void main(String[] args) {
        ExecutorService exec = Executors.newSingleThreadExecutor();
        for(int i = 0; i < 5; i++)
        	exec.execute(new LiftOff());
        exec.shutdown();
	}

} /*Output:
#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),
#1(9), #1(8), #1(7), #1(6), #1(5), #1(4), #1(3), #1(2), #1(1), #1(Liftoff!), 
#2(9), #2(8), #2(7), #2(6), #2(5), #2(4), #2(3), #2(2), #2(1), #2(Liftoff!), 
#3(9), #3(8), #3(7), #3(6), #3(5), #3(4), #3(3), #3(2), #3(1), #3(Liftoff!), 
#4(9), #4(8), #4(7), #4(6), #4(5), #4(4), #4(3), #4(2), #4(1), #4(Liftoff!), 
```
如果你需要运行大量的线程，并且它们所有运行的任务都需要访问文件系统。你可以用SingleThreadExecutor来运行这些线程，以确保任意时刻都只有一个任务在运行。
这样，你就不需要担心共享资源的同步问题（同时也不会过度使用文件系统）。当然，有时更好办法是在资源上增加同步，但是SingleThreadExecutor可以让你省去只是为了维护某些事物的原型而进行的各种协调努力。
通过序列化任务，你可以消除对序列化对象的需求。

**练习3：（1）使用本节展示的各种不同类型的执行器重复练习1。**

**答案请戳:point_right:[这里](solutions/Ex03.md)**

**练习4：（1）使用本节展示的各种不同类型的执行器重复练习2。**

**答案请戳:point_right:[这里](solutions/Ex04.md)**

## 四、从任务中产生返回值
Runnable是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口。在Java SE5中引入的Callable是一种具有类型参数的泛型，
它的类型参数表示的是从方法call()（而不是run()方法）中返回的值，并且必须使用ExecutorService.submit()方法调用它，下面是一个简单的示例：
```java
package concurrency;
import java.util.concurrent.*;
import java.util.*;

class TaskWithResult implements Callable<String> {
	private int id;
	public TaskWithResult(int id) { this.id = id; }
	public String call() {
		return "result of TaskWithReault " + id;
	}
}

public class CallableDemo {
	public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        ArrayList<Future<String>> result = new ArrayList<Future<String>>();
        for(int i = 0; i < 10; i++)
        	result.add(exec.submit(new TaskWithResult(i)));
        for(Future<String> fs : result)
        	try {
        		// get() blocks until completion:
        		System.out.println(fs.get());
        	} catch(InterruptedException e) {
        		return ;
        	} catch(ExecutionException e) {
        		System.out.println(e);
        	} finally {
        		exec.shutdown();
        	}
	}
} /*Output:
result of TaskWithReault 0
result of TaskWithReault 1
result of TaskWithReault 2
result of TaskWithReault 3
result of TaskWithReault 4
result of TaskWithReault 5
result of TaskWithReault 6
result of TaskWithReault 7
result of TaskWithReault 8
result of TaskWithReault 9
*///
```
submit()方法会产生Future对象，它用Callable返回结果的特定类型进行了参数化。你可以用isDone()方法来查询Future是否已经完成，该方法返回一个boolean值。
当任务完成时，Future对象具有一个结果，你可以调用get()方法来获取该结果。你也可以不用isDone()进行检查就直接调用get()，在这种情况下，get()将阻塞，
直至结果准备就绪。你还可以调用具有时间参数的get()，它会等待给定的时间后再视图获取结果。

**练习5：（2）修改练习2，使得计算所有斐波拉契数字的数值总和的任务用Callble完成。创建多个任务并显示结果。**

**答案请戳:point_right:[这里](solutions/Ex05.md)**

## 五、休眠
影响任务行为的一种简单的方式是调用sleep()，这将使任务中止执行给定的时间。在LiftOff类中，要是把对yield()的调用换成是调用sleep()，将得到如下结果：
```java
package concurrency;
import java.util.concurrent.*;

public class SleepingTask extends LiftOff {
    public void run() {
    	try {
    		while(countDown-- > 0) {
    			System.out.print(status());
    			// Old-style:
    			// Thread.sleep(100);
    			// The style of after Java SE5/6:
    			TimeUnit.MILLISECONDS.sleep(100);
    		}
    	} catch(InterruptedException e) {
    		System.err.println("Interrupted");
    	}
    }
	public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        for(int i = 0; i < 5; i++)
        	exec.execute(new SleepingTask());
        exec.shutdown();
	}
} /*Output:
#0(9), #4(9), #2(9), #3(9), #1(9), #4(8), #0(8), #2(8), #1(8), #3(8), #4(7), #0(7), #1(7), #2(7), 
#3(7), #4(6), #0(6), #3(6), #1(6), #2(6), #4(5), #0(5), #3(5), #1(5), #2(5), #0(4), #4(4), #1(4), 
#2(4), #3(4), #4(3), #0(3), #1(3), #3(3), #2(3), #0(2), #4(2), #3(2), #2(2), #1(2), #0(1), #4(1), 
#3(1), #2(1), #1(1), #0(Liftoff!), #4(Liftoff!), #1(Liftoff!), #3(Liftoff!), #2(Liftoff!), 
*///
```
对sleep()的调用会抛出IntrruptedException异常，并且它是在run()方法中被捕获的。因为异常不能跨线程传播到main()方法，所以你必须就地处理所有在任务内部产生的异常。

Java SE5引入了更加清楚的sleep()版本，它作为TimeUnit类的一部分。这个方法允许你指定sleep()延迟的*时间单元*，因此可以提供更好的可阅读性。

在上面的示例中，每个任务被调度的顺序，也就是打印语句的顺序，是不确定的。它依赖于底层的线程机制，这种机制因不同的操作系统而存在差异。
如果你你必须控制任务执行的顺序，那么最后使用“同步控制”（稍后会讲到），或者在某些情况下，压根不使用多线程，而是要编写自己的协作例程，
这些例程将会按照指定的顺序互相传递控制权。

**练习6：（2）创建一个任务，它将睡眠1至10秒之间的随机数量的时间，然后显示他它的睡眠时间并退出。创建并运行一定数量的这种任务。**

**答案请戳:point_right:[这里](solutions/Ex06.md)**

## 六、优先级
线程的***优先级*** 将该线程的重要性传递给了调度器。尽管CPU处理现有线程集的顺序是不确定的，但是调用器将倾向于让优先权最高的线程先执行。然而，这并不意味着优先权较低的线程就不执行
（也就是说，优先权不会导致死锁），只是执行的频率较低。

在绝大多数时间里，所有线程都是以默认的优先级运行的。试图操纵线程优先级通常是一种错误。

下面是一个演示优先级等级的示例，你可以用getPriority()来读取现有线程的优先级，并且在任何时刻都可以通过setPriority()来修改它。
```java
package concurrency;
import java.util.concurrent.*;

public class SimplePriorities implements Runnable {
    private int countDown = 5;
    private volatile double d;  // No optimization
    private int priority;
    public SimplePriorities(int priority) {
    	this.priority = priority;
    }
    public String toString() {
    	return Thread.currentThread() + ": " + countDown;
    }
    public void run() {
    	Thread.currentThread().setPriority(priority);
    	while(true) {
    		// An expensive, interruptable operation:
    		for(int i = 1; i < 100000; i++) {
    			d += (Math.PI + Math.E) / (double)i;
    			if(i % 1000 == 0)
    				Thread.yield();
    		}
    		System.out.println(this);
    		if(--countDown == 0) return;
    	}
    }
	public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        for(int i = 0; i < 5; i++)
        	exec.execute(new SimplePriorities(Thread.MIN_PRIORITY));
        exec.execute(new SimplePriorities(Thread.MAX_PRIORITY));
        exec.shutdown();
	}
} /*Output:
Thread[pool-1-thread-6,10,main]: 5
Thread[pool-1-thread-3,1,main]: 5
Thread[pool-1-thread-4,1,main]: 5
Thread[pool-1-thread-5,1,main]: 5
Thread[pool-1-thread-2,1,main]: 5
Thread[pool-1-thread-1,1,main]: 5
Thread[pool-1-thread-4,1,main]: 4
Thread[pool-1-thread-3,1,main]: 4
Thread[pool-1-thread-1,1,main]: 4
Thread[pool-1-thread-4,1,main]: 3
Thread[pool-1-thread-3,1,main]: 3
Thread[pool-1-thread-2,1,main]: 4
Thread[pool-1-thread-6,10,main]: 4
Thread[pool-1-thread-1,1,main]: 3
Thread[pool-1-thread-5,1,main]: 4
Thread[pool-1-thread-4,1,main]: 2
Thread[pool-1-thread-2,1,main]: 3
Thread[pool-1-thread-6,10,main]: 3
Thread[pool-1-thread-3,1,main]: 2
Thread[pool-1-thread-1,1,main]: 2
Thread[pool-1-thread-5,1,main]: 3
Thread[pool-1-thread-4,1,main]: 1
Thread[pool-1-thread-2,1,main]: 2
Thread[pool-1-thread-3,1,main]: 1
Thread[pool-1-thread-6,10,main]: 2
Thread[pool-1-thread-5,1,main]: 2
Thread[pool-1-thread-1,1,main]: 1
Thread[pool-1-thread-5,1,main]: 1
Thread[pool-1-thread-2,1,main]: 1
Thread[pool-1-thread-6,10,main]: 1
*///
```
toString()方法被覆盖，以便使用Thread.toString()方法来打印线程的名称、线程的优先级以及线程所属的“线程组”。你可以通过构造器来自己设置这个名称，这里是自动生成的。
覆盖后的toString()方法还打印了线程的倒计数值。注意，你可以在一个任务的内部，通过调用Thread.currentThread()来获的对驱动该任务的Thread对象的引用。

在run()里，执行了100000次的包括double类型的加法与处罚，是开销相当大的浮点运算。变量d是volatile的，以确保不进行任何编译器优化。如果没有加入这些复杂的运算的话，
也就看不到设置优先级的效果了（试一试：把包含double运算的for循环注释掉）。尽管向控制台打印也是开销大的操作，但在那种情况下看不出优先级的效果，因为向控制台打印的线程不能被中段
（否则，在多线程情况下控制台的显示就乱套了），而数字运算可以中断。这里运算的时间也足够的长，因此线程调度机制才来得及介入，交换任务并关注优先级，使得最高优先级线程被优先选择。

尽管JDK有10个优先级，但它与多数操作系统都不能映射的很好。因此唯一可移植的方法是当调整优先级的时候，只使用**MAX_PRIORITY、NORM_PRIORITY**和**MIN_PRIORITY**三种级别。

## 七、让步
如果知道已经完成了在run()方法中的一次循环迭代工作，就可以给线程调度机制一个暗示：你的工作已经做得差不多了，可以让别的线程使用CPU了。
这个暗示将通过调用yield()方法来作出（不过这只是一种暗示，并无法保证它一定会被采纳）。当调用yield()时，你也是在建议具有***相同优先级*** 的其他线程可以运行了。
因此，对于任何重要的控制或在调整应用时，都不能依赖于yield()。实际上，yield()经常被误用。

## 八、后台线程
所谓后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，
同时会杀死进程中所有的后台线程。反过来说，如果有任何的非后台线程还在运行，程序就不会终止。比如，执行main()的就是一个非后台线程。
```java
// Daemon threads don't prevent the program from ending.
package concurrency;
import java.util.concurrent.*;

public class SimpleDaemons implements Runnable {
    public void run() {
    	try {
    		while(true) {
    			TimeUnit.MILLISECONDS.sleep(100);
    			System.out.println(Thread.currentThread() + " " + this);
    		}
    	} catch(InterruptedException e) {
    		System.out.println("sleep() interrupted");
    	}
    }
	public static void main(String[] args) throws Exception {
        for(int i = 0; i < 10; i++) {
        	Thread daemon = new Thread(new SimpleDaemons());
        	daemon.setDaemon(true);  // Must call before start()
        	daemon.start();
        }
        System.out.println("All daemon started");
        TimeUnit.MILLISECONDS.sleep(200);
	}
} /*Output:
All daemon started
All daemon started
Thread[Thread-1,5,main] concurrency.SimpleDaemons@6b19c877
Thread[Thread-6,5,main] concurrency.SimpleDaemons@a627065
Thread[Thread-9,5,main] concurrency.SimpleDaemons@7c406074
Thread[Thread-2,5,main] concurrency.SimpleDaemons@2b1c13a3
Thread[Thread-5,5,main] concurrency.SimpleDaemons@4a676070
Thread[Thread-0,5,main] concurrency.SimpleDaemons@8730a97
Thread[Thread-3,5,main] concurrency.SimpleDaemons@1e6fa5a2
Thread[Thread-4,5,main] concurrency.SimpleDaemons@45669fee
Thread[Thread-7,5,main] concurrency.SimpleDaemons@5fab9cb7
Thread[Thread-8,5,main] concurrency.SimpleDaemons@3ce4fdb6
Thread[Thread-6,5,main] concurrency.SimpleDaemons@a627065
Thread[Thread-2,5,main] concurrency.SimpleDaemons@2b1c13a3
*///
```
注意，必须在将线程启动之前调用setDaemon()方法，才能把它设置为后台线程。

一旦main()方法完成其工作，就没有什么能阻止程序终止了，因为除了后台线程之外，已经没有其他线程在运行了。main()线程被设定为短暂的睡眠，所以可以观察到所有后台线程启动后的结果。
否则的话，后台线程会来不及运行，程序就终止了（试试缩短sleep()休眠的时间或干脆注释掉sleep()，以观察结果）。

我们还可以通过编写定制的ThreadFactory来定制由Executor创建的线程的属性（后台、优先级、名称）：
```java
package concurrency;
import java.util.concurrent.*;

public class DaemonThreadFactory implements ThreadFactory {
	@Override
	public Thread newThread(Runnable r) {
		Thread t = new Thread(r);
		t.setDaemon(true);
		return t;
	}
}
```
DaemonThreadFactory与普通的ThreadFactory的唯一差别就是它将其后台状态全部设置为了true。现在可以用DaemonThreadFactory作为参数传递给Executor.newCachedThreadPool()了：
```java
// Using a Thread Factory to create daemons:
package concurrency;
import java.util.concurrent.*;
import net.mindview.util.*;

public class DaemonFromFactory implements Runnable {
    public void run() {
    	try {
    		while(true) {
    			TimeUnit.MILLISECONDS.sleep(100);
    			System.out.println(Thread.currentThread() + " " + this);
    		}
    	} catch(InterruptedException e) {
    		System.out.println("Interrupted");
    	}
    }
	public static void main(String[] args) throws Exception {
        ExecutorService exec = Executors.newCachedThreadPool(new DaemonThreadFactory());
        for(int i = 0; i < 10; i++)
        	exec.execute(new DaemonFromFactory());
        System.out.println("All daemons started:");
        TimeUnit.MILLISECONDS.sleep(500);   
	}
} /* Output:
All daemons started:
Thread[Thread-3,5,main] concurrency.DaemonFromFactory@6494f6e7
Thread[Thread-1,5,main] concurrency.DaemonFromFactory@441ded1e
Thread[Thread-6,5,main] concurrency.DaemonFromFactory@6c0fa84
Thread[Thread-4,5,main] concurrency.DaemonFromFactory@5779465d
Thread[Thread-2,5,main] concurrency.DaemonFromFactory@724d9353
Thread[Thread-0,5,main] concurrency.DaemonFromFactory@48e67cb2
Thread[Thread-5,5,main] concurrency.DaemonFromFactory@68a76b0e
Thread[Thread-9,5,main] concurrency.DaemonFromFactory@2603da6e
Thread[Thread-8,5,main] concurrency.DaemonFromFactory@4b2c1afc
Thread[Thread-7,5,main] concurrency.DaemonFromFactory@132f7c29
Thread[Thread-1,5,main] concurrency.DaemonFromFactory@441ded1e
Thread[Thread-6,5,main] concurrency.DaemonFromFactory@6c0fa84
Thread[Thread-2,5,main] concurrency.DaemonFromFactory@724d9353
Thread[Thread-3,5,main] concurrency.DaemonFromFactory@6494f6e7
Thread[Thread-4,5,main] concurrency.DaemonFromFactory@5779465d
Thread[Thread-9,5,main] concurrency.DaemonFromFactory@2603da6e
Thread[Thread-5,5,main] concurrency.DaemonFromFactory@68a76b0e
Thread[Thread-0,5,main] concurrency.DaemonFromFactory@48e67cb2
Thread[Thread-8,5,main] concurrency.DaemonFromFactory@4b2c1afc
Thread[Thread-7,5,main] concurrency.DaemonFromFactory@132f7c29
Thread[Thread-6,5,main] concurrency.DaemonFromFactory@6c0fa84
Thread[Thread-1,5,main] concurrency.DaemonFromFactory@441ded1e
Thread[Thread-2,5,main] concurrency.DaemonFromFactory@724d9353
Thread[Thread-5,5,main] concurrency.DaemonFromFactory@68a76b0e
Thread[Thread-9,5,main] concurrency.DaemonFromFactory@2603da6e
Thread[Thread-3,5,main] concurrency.DaemonFromFactory@6494f6e7
Thread[Thread-4,5,main] concurrency.DaemonFromFactory@5779465d
Thread[Thread-0,5,main] concurrency.DaemonFromFactory@48e67cb2
Thread[Thread-7,5,main] concurrency.DaemonFromFactory@132f7c29
Thread[Thread-8,5,main] concurrency.DaemonFromFactory@4b2c1afc
Thread[Thread-6,5,main] concurrency.DaemonFromFactory@6c0fa84
Thread[Thread-1,5,main] concurrency.DaemonFromFactory@441ded1e
Thread[Thread-2,5,main] concurrency.DaemonFromFactory@724d9353
Thread[Thread-9,5,main] concurrency.DaemonFromFactory@2603da6e
Thread[Thread-5,5,main] concurrency.DaemonFromFactory@68a76b0e
Thread[Thread-4,5,main] concurrency.DaemonFromFactory@5779465d
Thread[Thread-7,5,main] concurrency.DaemonFromFactory@132f7c29
Thread[Thread-8,5,main] concurrency.DaemonFromFactory@4b2c1afc
Thread[Thread-3,5,main] concurrency.DaemonFromFactory@6494f6e7
Thread[Thread-0,5,main] concurrency.DaemonFromFactory@48e67cb2
Thread[Thread-6,5,main] concurrency.DaemonFromFactory@6c0fa84
Thread[Thread-1,5,main] concurrency.DaemonFromFactory@441ded1e
 *///~
```
每个创建ExecutorService的静态方法都可以被重载为接受一个ThreadFactory对象，而这个对象将被用来创建新的线程。
例如下面我们自定义一个DaemonThreadPoolExecutor类，并在构造器中使用前面的DaemonThreadFactory对象：
```java
package concurrency;
import java.util.concurrent.*;

public class DaemonThreadPoolExecutor extends ThreadPoolExecutor {
    public DaemonThreadPoolExecutor() {
    	super(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, 
    			new SynchronousQueue<Runnable>(), new DaemonThreadFactory());
    }
}
```
然后我们修改DaemonFromFactory.java，在其中使用DaemonThreadPoolExecutor类：
```java
package concurrency;
import java.util.concurrent.*;

public class DaemonFromFactory2 implements Runnable {
    public void run() {
    	try {
    		while(true) {
    			TimeUnit.MILLISECONDS.sleep(100);
    			System.out.println(Thread.currentThread() + " " + this);
    		}
    	} catch(InterruptedException e) {
    		System.out.println("Interrupted");
    	}
    }
	public static void main(String[] args) throws Exception {
        ExecutorService exec = new DaemonThreadPoolExecutor();
        for(int i = 0; i < 10; i++)
        	exec.execute(new DaemonFromFactory());
        System.out.println("All daemons started:");
        TimeUnit.MILLISECONDS.sleep(500);   
	}
} /* (Running results are the same as DaemonFromFactory.java programs) *///~
```
程序执行结果与DaemonFromFactory.java的运行结果相同。

我们还可以通过调用isDaemon()方法来确定线程是否是一个后台线程。***如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程***，如下例所示：
```java
package concurrency;
import java.util.concurrent.TimeUnit;

class Daemon implements Runnable {
	private Thread[] t = new Thread[10];
	public void run() {
		for(int i = 0; i < t.length; i++) {
			t[i] = new Thread(new DaemonSpawn());
			t[i].start();
			System.out.print("DaemonSpawn " + i + " started, ");
		}
		for(int i = 0; i < t.length; i++)
			System.out.print("t[" + i + "].isDaemon() = " + t[i].isDaemon() + ", ");
		while(true)
			Thread.yield();
	}
}

class DaemonSpawn implements Runnable {
	public void run() {
		while(true) 
			Thread.yield();
	}
}

public class Daemons {
    public static void main(String[] args) throws Exception {
    	Thread d = new Thread(new Daemon());
    	d.setDaemon(true);
    	d.start();
    	System.out.print("d.isDaemon() = " + d.isDaemon() + ", ");
    	// Allow the daemon threads to
    	// finish their startup processes:
    	TimeUnit.SECONDS.sleep(1);
    }
} /*Output:
d.isDaemon() = true, DaemonSpawn 0 started, DaemonSpawn 1 started, DaemonSpawn 2 started, 
DaemonSpawn 3 started, DaemonSpawn 4 started, DaemonSpawn 5 started, DaemonSpawn 6 started, 
DaemonSpawn 7 started, DaemonSpawn 8 started, DaemonSpawn 9 started, t[0].isDaemon() = true, 
t[1].isDaemon() = true, t[2].isDaemon() = true, t[3].isDaemon() = true, t[4].isDaemon() = true, 
t[5].isDaemon() = true, t[6].isDaemon() = true, t[7].isDaemon() = true, t[8].isDaemon() = true, 
t[9].isDaemon() = true, 
*///
```
Daemon线程被设置成了后台模式，然后派生出许多子线程DaemonSpawn，这些子线程并没有被显示地设置为后台模式，不过它们的确是后台线程。
接着，Daemon线程进入了无限循环，并在循环里调用yield()方法把控制权交给其他线程。

你应该知道，后台线程在不执行finally子句的情况下就会终止其run()方法：
```java
package concurrency;
import java.util.concurrent.TimeUnit;

class ADaemon implements Runnable {
	public void run() {
		try {
			System.out.println("Starting ADaemon");
			TimeUnit.SECONDS.sleep(1);
		} catch(InterruptedException e) {
			System.out.println("Exiting via InterruptedException");
		} finally {
			System.out.println("This should always run?");
		}
	}
}

public class DaemonsDontRunFinally {
	public static void main(String[] args) {
        Thread t = new Thread(new ADaemon());
        t.setDaemon(true);
        t.start();
	}
} /*Output:
Starting ADaemon
*///
```
当你运行这个程序时，你将看到finally子句是不会被执行的，但是如果注释掉```t.setDaemon();```语句，finally子句将会执行。

这就对了，即便你使用了fianlly希望在程序终止前执行它，但这对后台线程是不起效果的。因为当最后一个非后台线程终止时，所有的后台线程也会随之“突然”终止。
因此一旦main()退出，JVM就会立即关闭所有的后台进程，而不会出现你希望的确认形式，以这种不优雅的方式关闭后台线程，不能算是一种好的思想。
非后台的Executor则是一种更好的选择，因为Executor控制的所有任务可以同时被关闭，并且是以有序的方式执行关闭。

**练习7：（2）在Daemons.java中使用不同的休眠时间，并观察结果。**

**答案请戳:point_right:[这里](solutions/Ex07.md)**

**练习8：（1）把MoreBasicThreads.java中的所有线程修改成后台线程，并验证一旦main()退出，程序立刻终止。**

**答案请戳:point_right:[这里](solutions/Ex08.md)**

**练习9：（3）修改SimplePriorities.java，使得定制的ThreadFactory可以设置线程的优先级。**

**答案请戳:point_right:[这里](solutions/Ex09.md)**

## 九、编码的变体
到目前为止，在你所见到的示例中，任务类都是实现了Runnable。在非常简单的情况下，你可能会希望使用直接从Thread继承这种可替代的方式，就像下面这样：
```java
// Inheriting directly from the Thread class.
package concurrency;

public class SimpleThread extends Thread {
    private int countDown = 5;
    private static int threadCount = 0;
    public SimpleThread() {
    	// Store the thread name:
    	super(Integer.toString(++threadCount));
    	start();
    }
    public String toString() {
    	return "#" +  getName() + "(" + countDown + "), ";
    }
    public void run() {
    	while(true) {
    		System.out.print(this);
    		if(--countDown == 0)
    			return ;
    	}
    }
	public static void main(String[] args) {
        for(int i = 0; i < 5; i++)
        	new SimpleThread();
	}
} /*Output:
#1(5), #3(5), #1(4), #3(4), #1(3), #3(3), #1(2), #3(2), #1(1), #4(5), #2(5), #4(4), 
#3(1), #2(4), #2(3), #2(2), #5(5), #5(4), #2(1), #4(3), #4(2), #5(3), #4(1), #5(2), #5(1), 
*///
```
你可以通过调用适当的Thread构造器为Thread对象赋予具体的名称，这个名称可以使用getName()获得，然后通过toString()返回。

另一种可能会看到的惯用法是自管理的Runnable：
```java
// A Runnable containing its own driver Thread.
package concurrency;

public class SelfManaged implements Runnable {
    private int countDown = 5;
    private Thread t = new Thread(this);
    public SelfManaged() { t.start(); }
    public String toString() {
    	return Thread.currentThread().getName() + "(" + countDown + "), ";
    }
    public void run() {
    	while(true) {
    		System.out.print(this);
    		if(--countDown == 0)
    			return ;
    	}
    }
	public static void main(String[] args) {
        for(int i = 0; i < 5; i++)
        	new SelfManaged();
	}

} /*Output:
Thread-0(5), Thread-3(5), Thread-3(4), Thread-3(3), Thread-4(5), Thread-4(4), Thread-4(3), 
Thread-1(5), Thread-1(4), Thread-1(3), Thread-1(2), Thread-1(1), Thread-2(5), Thread-2(4), 
Thread-2(3), Thread-4(2), Thread-4(1), Thread-3(2), Thread-0(4), Thread-0(3), Thread-0(2), 
Thread-0(1), Thread-3(1), Thread-2(2), Thread-2(1), 
*///
```
这与从Thread继承并没有什么特别的差异，只是语法稍有些晦涩。但是，实现接口可以让你再继承另外一个不同的类，而从Thread继承将不行。

注意，start()方法是在构造器中被调用的。这个示例相当简单，因此可能是安全的。但是在构造器中启动线程可能会有问题，因为另一个任务可能会在构造器结束之前就开始执行，
这意味着该任务能够访问处于不稳定状态的对象。这就是优选Executor而不是显式地创建Thread对象的另一个的原因：

有时将线程代码隐藏在内部类中将会很有用，就像下面这样：
```java
// Creating threads with inner classes.
package concurrency;
import java.util.concurrent.*;

// Using a named inner class:
class InnerThread1 {
	private int countDown = 5;
	private Inner inner;
	private class Inner extends Thread {
		Inner(String name) {
			super(name);
			start();
		}
		public void run() {
			try {
				while(true) {
					System.out.println(this);
					if(--countDown == 0)
						return;
					sleep(10);
				}
			} catch(InterruptedException e) {
				System.out.println("interrupted");
			}
		}
		public String toString() {
			return getName() + ": " + countDown;
		}
	}
	public InnerThread1(String name) {
		inner = new Inner(name);
	}
}

// Using an anonymous inner class:
class InnerThread2 {
	private int countDown = 5;
	private Thread t;
	public InnerThread2(String name) {
		t = new Thread(name) {
			public void run() {
				try {
					while(true) {
						System.out.println(this);
						if(--countDown == 0) return;
						sleep(10);
					}
				} catch(InterruptedException e) {
					System.out.println("sleep() interrupted");
				}
			}
			public String toString() {
				return getName() + ": " + countDown;
			}
		};
		t.start();
	}
}

// Using a named Runnable implementation:
class InnerRunnable1 {
	private int countDown = 5;
	private Inner inner;
	private class Inner implements Runnable {
		Thread t;
		Inner(String name) {
			t= new Thread(this, name);
			t.start();
		}
		public void run() {
			try {
				while(true) {
					System.out.println(this);
					if(--countDown == 0) return ;
					TimeUnit.MILLISECONDS.sleep(10);
				}
			} catch(InterruptedException e) {
				System.out.println("sleep() interrupted");
			}
		}
		public String toString() {
			return t.getName() + ": " + countDown;
		}
	}
	public InnerRunnable1(String name) {
		inner = new Inner(name);
	}
}

// Using an anonymous Runnable implementation:
class InnerRunnable2 {
	private int countDown = 5;
	private Thread t;
	public InnerRunnable2(String name) {
		t = new Thread(new Runnable() {
			public void run() {
				try {
					while(true) {
						System.out.println(this);
						if(--countDown == 0) return;
						TimeUnit.MILLISECONDS.sleep(10);
					}
				} catch(InterruptedException e) {
					System.out.println("sleep() interrupted");
				}
			}
			public String toString() {
				return Thread.currentThread().getName() + ": " + countDown;
			}
		}, name);
		t.start();
	}
}

// A separate method to run some code as a task:
class ThreadMethod {
	private int countDown = 5;
	private Thread t;
	private String name;
	public ThreadMethod(String name) {
		this.name = name;
	}
	public void runTask() {
		if(t == null) {
			t = new Thread(name) {
				public void run() {
					try {
						while(true) {
							System.out.println(this);
							if(--countDown == 0) return;
							sleep(10);
						}
					} catch(InterruptedException e) {
						System.out.println("sleep() interrupted");
					}
				}
				public String toString() {
					return getName() + ": " + countDown;
				}
			};
			t.start();
		}
	}
}

public class ThreadVariations {
	public static void main(String[] args) {
        new InnerThread1("InnerThread1");
        new InnerThread2("InnerThread2");
        new InnerRunnable1("InnerRunnable1");
        new InnerRunnable2("InnerRunnable2");
        new ThreadMethod("ThreadMethod").runTask();
	}
} /*Output:
InnerThread1: 5
InnerThread2: 5
InnerRunnable1: 5
InnerRunnable2: 5
ThreadMethod: 5
InnerThread1: 4
InnerThread2: 4
InnerRunnable1: 4
InnerRunnable2: 4
ThreadMethod: 4
InnerThread1: 3
InnerThread2: 3
InnerRunnable1: 3
InnerRunnable2: 3
ThreadMethod: 3
InnerThread1: 2
InnerThread2: 2
InnerRunnable1: 2
InnerRunnable2: 2
ThreadMethod: 2
InnerThread1: 1
InnerThread2: 1
InnerRunnable2: 1
InnerRunnable1: 1
ThreadMethod: 1
*///
```
InnerThread1创建了一个扩展自Thread的显式内部类，并且在构造器中创建了这个内部类的一个实例。如果你在外部类中需要调用内部类的某个特殊能力（方法），
那这么做将会很有必要。但是，在大多数时候，创建线程的原因只是为了使用Thread的通用的能力，因此就不必创建显式的内部类了。

InnerThread2展示了可替代的方式：在外部类的构造器中创建一个Thread类型的匿名内部类，因为它的实例向上转型为了Thread类型。因此如果外部类中的其他方法需要访问它时，
只需将其作为Thread类型来处理，而不必关心它的确切类型。

该示例的第三个和第四个类重复了前面两个类，只是它们使用的是Runnable接口而不是Thread类。

**练习10：（4）按照ThreadMethod类修改练习5，使得runTask()方法将接受一个参数，表示要计算总和的斐波那契数字的数量，并且每次调用runTask()时，它将返回对submit()的调用所产生的Future对象。**

**答案请戳:point_right:[这里](solutions/Ex10.md)**

## 十、术语
到目前为止，你应该看到要执行的任务与驱动它的线程之间有一定的差异，这个差异在Java类库中尤为明显，因为你对Thread类没有任何控制权（并且这种情况在使用Executor时更加明显，
因为Executor将替你处理线程的创建和管理）。你创建任务，并通过某种方式将一个线程附着到任务上，以使得这个线程可以驱动任务。

在Java中，Thread类自身不执行任何操作，它只是驱动赋予它的任务，但是我们在研究线程时，总是习惯性地说：线程执行了这项或那项动作。因此，你会认为“线程就是任务”，
当我第一次接触Java线程时，这种印象非常强烈，以至于认为它们就是同一个事物；进而当继承Thread类时，会认为我继承了一个任务。
另外，Runnable接口的名字也很糟糕，我认为用Task命名它会更好。因为如果这个接口表示的是“它执行能做的事情”，那么这种命名方式是可以的，
但是如果它是要表示某类事物的更高层次的抽象，例如Task，那么***概念名*** 将更恰当。

从概念上讲，我们希望能创建出各自独立运行的任务，然后说“开始”，就不再操心其细节了。但是在物理上，创建线程可能会代价高昂，因此你必须保存并管理它们。
所以从现实角度看，将任务从线程中分离出来是有意义的。另外，Java的线程机制是基于C语言的低级的p线程方式，这是一种你必须深入研究，并且需要完全理解其所有事物和细节的方式。
因此，为了处理更高的抽象级别，使用Java编写代码时，必须遵循一定的规则（我将在本章中努力演示这些规则）。

为了避免上述术语上的混乱，我使用“任务”来描述将要执行的工作，只有在描述驱动任务的具体机制时，才使用“线程”。如果只是在概念级别上讨论系统，那就只使用“任务”，
而压根不需要提及驱动机制。

## 十一、加入一个线程
假设在某程序中有一个线程A，我们在线程A中可以让另一个线程（假设为：线程B）调用join()方法，其效果是线程A将被挂起，它将等待线程B执行结束（即当B.isAlive()返回为假），然后才会继续执行。

也可以在调用join()时带上一个超时参数（单位可以是：秒、毫秒、纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。

对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try-catch子句。

下面这个例子演示了所有这些操作：
```java
// Understanding join().
package concurrency;

class Sleeper extends Thread {
	private int duration;
	public Sleeper(String name, int sleepTime) {
		super(name);
		duration = sleepTime;
		start();
	}
	public void run() {
		try {
			sleep(duration);
		} catch(InterruptedException e) {
			System.out.println(getName() + " was interrupted. " + 
		        "isInterrupted(): " + isInterrupted());
			return;
		}
		System.out.println(getName() + " has awakened");
	}
}

class Joiner extends Thread {
	private Sleeper sleeper;
	public Joiner(String name, Sleeper sleeper) {
		super(name);
		this.sleeper = sleeper;
		start();
	}
	public void run() {
		try {
			sleeper.join();
		} catch(InterruptedException e) {
			System.out.println("Interrupted");
		}
		System.out.println(getName() + " join completed");
	}
}

public class Joining {
	public static void main(String[] args) {
        Sleeper
            sleepy = new Sleeper("Sleepy", 1500),
            grumpy = new Sleeper("Grumpy", 1500);
        Joiner 
            dopey=  new Joiner("Dopey", sleepy),
            doc = new Joiner("Doc", grumpy);
        grumpy.interrupt();	
	}
} /*Output:
Grumpy was interrupted. isInterrupted(): false
Doc join completed
Sleepy has awakened
Dopey join completed
*///
```
Sleeper是一个Thread类型，它要休眠一段时间，这段时间是通过构造器参数指定的。在其run()方法中，sleep()方法有可能休眠期满后返回，也可能被中断。
如果被中断，它会抛出InterruptedException异常，则在catch子句中打印isInterrupted()的返回值。当另一个线程使用该线程调用interrupt()时，
将给该线程设定一个标志，表明该线程已经被中断。

然而，异常被捕获时将清理这个标志，因此在catch子句中输出的isInterrupted()返回值总是为假。除异常以外，这个标志还可用于其他情况，比如线程可以检查其中断状态。

因为在Joiner线程中Sleeper线程调用了join()方法，所以Joiner线程将会被挂起，等待Sleeper线程醒来。在main()方法里面，每个Joiner的构造器中都传入了一个Sleeper实例。
从输出结果看到，只有当Sleeper休眠期满或被中断后，Joiner才能打印一个语句，以此表示运行结束。另外，因为名为“grumpy”的Sleeper对象调用了interrupt()方法，
所以它会被中断并抛出异常，因此catch子句捕获了该异常。

注意，Java SE5的java.util.concurrent类库包含诸如CyclicBarrier(循环屏蔽)这样的工具，它们可能比最初的线程类库中的join()更加适合。

## 十二、创建有响应的用户界面
如前所述，使用线程的动机之一就是建立有响应的用户界面。尽管我们要到第22章才接触到图形用户界面，但下面还是给出了一个基于控制台用户界面的简单教学示例。
下面的例子有两个版本：一个是不创建线程而只在main()中处理运算，因此它无法同时读取控制台输入；另一个使用线程把运算放在单独的任务中运行，同时其他线程读取控制台输入，
这样就可以在进行运算的同时监听控制台输入了。
```java
package concurrency;

class UnresponsiveUI {
	private volatile double d = 1;
	public UnresponsiveUI() throws Exception {
		while(d > 0)
			d = d + (Math.PI + Math.E) / d;
		System.in.read();   // Never gets here
	}
}

public class ResponsiveUI extends Thread {
    private static volatile double d = 1;
    public ResponsiveUI() {
    	setDaemon(true);
    	start();
    }
    public void run() {
    	while(true) {
    		d = d + (Math.PI + Math.E) / d;
    	}
    }
	public static void main(String[] args) throws Exception {
        //! new UnresponsiveUI();  // Must kill this process
		new ResponsiveUI();
		System.out.print("Please input: ");
		System.in.read();
		System.out.println(d);  // Shows progress
	}
} /*Output:
Please input: hello!
75380.52117399393
*///
```
UnresponsiveUI在一个无限循环里执行运算（因为d永远不可能小于等于0），程序也就不可能执行到读取控制台输入的那一行。如果把建立UnresponsiveUI对象的那一行注释去掉再运行程序，
那么要终止程序的话，只能杀死这个进程。

要想让程序即执行运算，同时还能从控制台读取输入，就要创建线程用于计算，并设置为后台执行，这样它就可以在执行一段时间后将处理器让给别的任务（读取控制台输入），
于是程序既可以读取控制台输入，又能同时在后台运行计算。当你完成输入按下“回车”键后，就可以打印出运算结果。

## 十三、线程组
**线程组**持有一个线程集合。线程组的价值可以引用Joshua Bloch的话来总结，他在Sun时是软件架构师，订正并加大地改善了JDK 1.2中Java集合类库：

***“最好把线程组看成是一次不成功的尝试，你只要忽略它就可以了。”***

如果你花费了大量的时间和精力试图发现线程组的价值，那么你可能会惊讶，为什么没有来自Sun的关于这个主题的官方声明，多年以来，对于Java上发生的其他问题也同样如此。
诺贝尔经济学奖得主Joseph Stiglitz的生活哲学可以用来解释这个原因，它被称为**承诺升级理论**： 

***“继续错误的代价由别人承担，而承认错误的代码由自己承担。”***

## 十四、捕获异常
由于线程的本质特性，使得你不能捕获从线程中逃逸的异常。一旦异常逃出任务的run()方法，它就会向外传播到控制台，除非你采取特殊的步骤捕获这种错误的异常。
在Java SE5之前，你可以使用线程组来捕获这些异常，但在Java SE5之后，可以用Executor来解决这个问题，因此你就不需要在了解有关线程组的任何知识了。

下面的任务总是会抛出一个异常，该异常会传播的其run()方法之外，并且main()方法展示了当你运行它时所发生的的事情：
```java
package concurrency;
import java.util.concurrent.*;

public class ExceptionThread implements Runnable {
    public void run() {
    	throw new RuntimeException();
    }
	public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        exec.execute(new ExceptionThread());
	}
} /*Output:
Exception in thread "pool-1-thread-1" java.lang.RuntimeException
	at concurrency.ExceptionThread.run(ExceptionThread.java:6)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
*///
```
可以看到线程直接抛出了一个异常，如果我们在main()方法中使用try-catch语句试图捕获这个异常，你会发现这是不起作用的：
```java
package concurrency;
import java.util.concurrent.*;

public class NaiveExceptionHandling {
	public static void main(String[] args) {
        try {
        	ExecutorService exec = Executors.newCachedThreadPool();
        	exec.execute(new ExceptionThread());
        } catch(RuntimeException e) {
        	// This statement will Not execute!
        	System.out.println("Exception has been handled!");
        }
	}
}
```
这将产生与前一个示例相同的结果：异常未被捕获。

为了解决这个问题，我们需要修改Executor产生线程的方式。Thread.UncaughtExceptionHandler是Java SE5中的新接口，它允许你在每个Thread对象上都附着一个异常处理器。
Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。为了使用它，我们创建了一个新类型的ThreadFactory，
它将在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。我们将这个工厂传递给Executors创建新的ExecutorService的方法：
```java
package concurrency;
import java.util.concurrent.*;

class ExceptionThread2 implements Runnable {
	public void run() {
		Thread t = Thread.currentThread();
		System.out.println("run() by " + t);
		System.out.println("en = " + t.getUncaughtExceptionHandler());
	    throw new RuntimeException();
	}
}

class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
	public void uncaughtException(Thread t, Throwable e) {
        System.out.println("caught " + e);		
	}
}

class HandlerThreadFactory implements ThreadFactory {
	public Thread newThread(Runnable r) {
		System.out.println(this + " creating new Thread");
		Thread t = new Thread(r);
		System.out.println("created " + t);
		t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
		System.out.println("en = " + t.getUncaughtExceptionHandler());
		return t;
	}
}

public class CaptureUncaughtException {
	public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory());
        exec.execute(new ExceptionThread2());
	}
} /*Output:
concurrency.HandlerThreadFactory@5c647e05 creating new Thread
created Thread[Thread-0,5,main]
en = concurrency.MyUncaughtExceptionHandler@33909752
run() by Thread[Thread-0,5,main]
en = concurrency.MyUncaughtExceptionHandler@33909752
concurrency.HandlerThreadFactory@5c647e05 creating new Thread
created Thread[Thread-1,5,main]
en = concurrency.MyUncaughtExceptionHandler@aafbb87
caught java.lang.RuntimeException
*///
```
在程序中添加了额外的跟踪机制，用来验证工厂创建的线程会传递给UncaughtExceptionHandler。你现在可以看到，未捕获的异常是通过uncaughtException()方法来捕获的。

上面的示例使得你可以按照具体情况逐个地设置异常处理器。如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方式是调用Thread类中的静态方法
setDefaultUncaughtExceptionHandler()，向方法中传递一个异常处理器实例，将其设置为默认的未捕获异常处理器：
```java
package concurrency;
import java.util.concurrent.*;

public class SettingDefaultHandler {
	public static void main(String[] args) {
        Thread.setDefaultUncaughtExceptionHandler(
        		new MyUncaughtExceptionHandler());
        ExecutorService exec = Executors.newCachedThreadPool();
        exec.execute(new ExceptionThread());
	}
} /*Output:
caught java.lang.RuntimeException
*///
```
这个处理器只有在不存在线程专有的未捕获异常处理器的情况下才会被调用。系统会检查线程专有版本，如果没有发现，则检查线程组是否有其专有的uncaughtException()方法，
如果也没有，再调用“默认未捕获异常处理器”（defaultUncaughtExceptionHandler）。

---

### [上一节：并发的多面性](21.1_The_many_faces_of_concurrency.md)　　　　　　　　[下一节：共享受限资源](21.3_Resolving_shared_resource_contention.md)












