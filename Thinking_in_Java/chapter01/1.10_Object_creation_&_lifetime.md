# 1.10 对象的创建和生命期

在使用对象时，最关键的问题之一便是它们的生成和销毁方式。每个对象为了生存都需要资源，尤其是内存。

对象的数据位于何处？怎样控制对象的生命周期？C++认为效率控制是最重要的议题，所以给程序员提供了选择的权力。为了追求最大的执行速度，
对象的存储空间和生命周期可以在编写程序是确定，这可以通过将对象置于堆栈（它们有时被称为自动变量（automatic variable）或限域变量（scoped variable））
或静态存储区域内实现。这种方式将存储空间分配和释放放置于优先考虑的位置，某些情况下这样控制非常有价值。但是，也牺牲了灵活性，
因为必须在编写程序时知道对象确切的数量、生命周期和类型。如果试图解决更一般化的问题，例如计算机辅助设计、仓库管理或者空中交通控制，
这种方式就显得过于受限制了。

第二种方式是在被称为堆（heap）的内存池中***动态地*** 创建对象。在这种方式中，直到运行时才知道需要多少对象，它们的生命周期如何，以及它们的具体类型是什么。
这些问题的答案只能在程序运行时相关代码被执行到的那一刻才能确定。因为存储空间是在运行时被动态管理的，所以需要大量的时间在堆中分配存储空间，
这可能要远远大于在堆栈中创建存储空间的时间。

动态方式有这样一个一般性的逻辑假设：对象趋向于变得复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大冲击。动态方式所带来的更大的灵活性正是解决一般编程问题的要点所在。

***Java完全采用了动态内存分配方式（基本类型只是一种特例）***。每当想要创建新对象时，就要使用new关键字来构建此对象的动态实例。

还有一个议题，就是对象的生命周期。对于允许在堆栈上创建对象的语言，编译器可以确定对象存活的时间，并可以自动销毁它。然而，如果是在堆上创建对象，
编译器就会对它的生命周期一无所知。***Java提供了被称为“垃圾回收器”的机制，它可以自动发现对象何时不再被使用，并继而销毁它***。垃圾回收器非常有用，
因为它减少了所必须考虑的议题和必须编写的代码。更重要的是，垃圾回收器提供了更高级的保障，可以避免暗藏的内存泄漏问题，这个问题已经使许多C++项目折戟沉沙，
因为它必须通过编程方式来确定何时销毁对象。

Java垃圾回收器被设计用来处理内存释放问题。它“知道”对象何时不再被使用，并且自动释放对象占用的内存。这一点同所有对象的单根继承结构和只能在堆上创建对象，
这两个特性结合起来，使得用Java编程的过程较C++编程要简单得多。

---

### [上一节：容器](1.9_Containers.md)　　　　　　　　[下一节：异常处理：处理错误](1.11_Exception_handling：dealing_with_errors.md)