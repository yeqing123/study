# 抽象过程

所有编程语言都提供抽象机制。可以认为，人们所能够理解的问题的复杂性直接取决于抽象的类型和质量。所谓的“类型”是指“所抽象的是什么？”
汇编语言是对底层机器的轻微抽象。接着出现的许多所谓“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。这些语言在汇编语言基础上有了大幅的改进，
但是它们所作的主要抽象仍要求在解决问题时要基于计算机的结构，而不是基于所解决的问题的结构来考虑。程序员必须建立起在机器模型和实际待解决问题的模型之间的关联。
建立这种映射是费力的，而且这不属于编程语言所固有的功能，这使得程序难以编写，并且维护代价高昂，同时也产生了作为副产物的整个“编程方法”行业。

另一种对机器建模的方法就是只针对待解问题建模。早起的编程语言，如LISP何APL和PROLOG等，它们所采取的方式对于它们所要解决的特定类型的问题都是不错的解决方案，
但是一旦超出其特定领域，它们就力不从心了。

面向对象方式通过向程序员提供表示问题空间中的元素的工具而更进了一步。这种表示方式非常通用，使得程序员不会受限于任何特定类型的问题。
我们将问题空间中的元素及其在解空间中的表示成为“对象”。（你还需要一些无法类比为问题空间元素的对象）这种思想的实质是：
*程序可以通过添加新类型的对象使自身适用于某个特定问题*。因此，当你在阅读描述解决方案的代码的同时，也是在阅读问题的表述。所以，OOP允许根据问题来描述问题，
而不是根据运行解决方案的计算机来描述问题。但是它仍然与计算机有联系：每个对象看起来都有点像一台微型计算机——它具有状态，还具有操作，用户可以要求对象执行这些操作。如果要对现实世界中的对象作类比，那么说它们都具有***特性*** 和***行为*** 似乎不错。

Alan Kay曾经总结了第一个成功的面向对象语言、同时也是Java所基于的语言之一的Smalltalk的五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式：
1. **万物皆对象。**将对象视为奇特的变量，它可以存储数据，除此以外，你还可以要求它在自身上执行操作。理论上讲，你可以抽取带求解问题的任何*概念化构建*
  （狗、建筑物、服务等），将其表现为程序中的对象。
2. **程序是对象的集合，他们通过发送消息来告知彼此所要做的。**要想请求一个对象，就必须对该对象发送一条消息。更具体地说，可以把消息想象为某个特定对象的方法的调用请求。
3. **每个对象都有自己的由其他对象所构成的存储。**换句话说，可以通过创建现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。
4. **每个对象都拥有其类型。**按照通用的说法，“每个对象都是某个*类（class）* 的一个*实例（instance）* ”，这里“类”就是“类型”的同义词。每个类区别与其他类的最重要的特性就是“可以发送什么样的消息给它”。
5. **某一特定类型的所有对象都可以接收同样的消息。**因为“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这意味着可以编写与“几何形”交互并自动处理所有与几何形性质相关的事物的代码。这种*可替代性（substitutability）* 是OOP中最强有力的概念之一。

Booch对对象提出了一个更加简洁的描述：*对象具有状态、行为和标识。* 这意味着每一个对象都可以拥有内部数据（它们给出了该对象的状态）和方法（它们产生行为），
并且每一个对象都可以唯一地与其他对象区分开来，具体来说，就是每一个对象在内存中都有一个唯一的地址。

---

### [下一节：每个对象都有一个接口](1.2_An_object_has_an_interface.md)