# 1.9 容器

通常说来，如果不知道在解决某个特定问题时需要多少个对象，或者它们将存活多久，那么就不可能知道如何存储这些对象。如何才能知道需要多少空间来创建这些对象呢？
答案是你不可能知道，因为这类信息只有在运行时才能获得。

对于面向对象设计中的大多数问题而言，这个问题的解决方案似乎过于轻率：创建另一种对象类型。这种新的对象类型持有对其他对象的引用。
当然，你也可以用大多数语言中都有的数组类型来实现同样的功能。但是这个通常被称为“容器”的新对象，在任何需要时都可扩充自己以容纳你置于其中的所有东西。
因此不需要知道将来会有多少对象置于容器中，只需创建一个容器对象即可，它自己会处理所有细节。

幸运的是，好的OOP语言都有一组容器，它们作为开发包的一部分。在C++中，容器是标准C++类库的一部分，经常被称为标准模板类库（Standard Template Library, STL）。
Java在其标准类库中也包含有大量容器。在某些类库中，一两个通用容器足够满足所有的需要；但是在其他类库（例如Java中），具有满足不同需要的各种类型的容器。

从设计的观点来看，真正需要的只是一个可以被操作，从而解决问题的序列。如果单一类型的容器可以满足所有需要，那么就没有理由设计不同种类的序列了。
然而还是需要对容器有所选择，这有两个原因。**第一，不同容器提供了不同类型的接口和外部行为。** 堆栈相比于队列就具备不同的接口和行为，
也不同于集合和列表的接口和行为。**第二，不同的容器对于某些操作具有不同的效率。** 最好的例子就是两种List的比较：ArrayList和LinkedList。
它们都是具有相同接口和外部行为的简单的序列，但是它们对某些操作所花费的代价却是天壤之别。

### 参数化类型
在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型：Object。单根继承结构意味着所有东西都是Object类型，所以可以存储Object的容器就可以存储任何类型。
这使得容器很容易被复用。

由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object，因此它会丢失其身份。当把它取回时，就获取了一个Object对象的引用，
而不是置入时的那个类型的对象的引用。所以，怎样才能将它变回先前置入容器中时的具有实用接口的对象呢？

这里再度用到了转型，但这一次不是向继承结构的上层转型为一个更泛化的类型，而是向下转型为更具体的类型。这种转型的方式称为**向下转型**。向上转型是安全的，
但是除非我们确切知道所要处理的对象的类型，否则向下转型几乎都是不安全的。

然而向下转型也并非是彻底危险的，因为如果向下转型为错误的类型，就会得到被称为异常的运行时错误，稍后会介绍什么是异常。尽管如此，当从容器中取出对象引用时，
还是必须要以某种方式记住这些对象究竟是什么类型，这样才能执行正确的向下转型。

向下转型和运行时的检查都需要额外的程序运行时间，也需要程序员付出更多的心血。那么创建这样的容器，它知道自己所保存的对象的类型，从而不需要向下转型以及消除犯错误的可能，这样不是更有意义吗？这种解决方案被称为***参数化类型机制***。参数化类型就是一个编译器可以自动定制作用于特定类型上的类。例如，通过使用参数化类型，
编译器可以定制一个只接受和取出Shape对象的容器。

Java SE5的重大变化之一就是增加了参数化类型，在Java中它称为***范型***。一对尖括号，中间包含类型信息，通过这些特征就可以识别对范型的使用。
例如，可以用下面这样的语句来创建一个存储Shape的ArrayList：
```java
ArrayList<Shape> shapes = new ArrayList<Shape>();
```

为了利用范型的优点，很多标准类库构件都已经进行了修改。就像我们将要看到的那样，范型对本书中的许多代码都产生了重要的影响。

---

### [上一节：单根继承结构](1.8_The_singly_rooted_hierarchy.md)　　　　　　　　[下一节：对象的创建和生命期](1.10_Object_creation_&_lifetime.md)