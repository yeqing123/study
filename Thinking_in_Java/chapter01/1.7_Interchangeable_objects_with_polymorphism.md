# 1.7 伴随多态的可互换对象

在处理类型的层次结构时，经常想把一个对象不当作他所属的特定类型来对待，而是将其当作其基类的对象来对待。这使得人们可以编写出不依赖于特定类型的代码。
在“几何形”的例子中，方法操作的都是泛化（generic）的形状，而不关心它们是圆形、正方形、三角形还是其他什么尚未定义的形状。所有的几何形状都可以被绘制、
擦除和移动，所以这些方法都是直接对一个几何形对象发送消息；它们不用担心对象将如何处理消息。

但是，在试图将导出类型的对象当作其泛化的基类型对象来看待时，仍然存在一个问题。如果某个方法要让泛化的几何形状绘制自己、让泛化的交通工具行驶，
或者让泛化的鸟类移动，那么编译器在编译时是不可能知道应该执行哪一段代码的。当发送这样的消息时，程序员并不想知道哪一段代码将被执行；
而对象会依据自己的具体类型来执行恰当的代码。

如果不需要知道哪一段代码会被执行，那么当添加新的子类型时，不需要更改调用它的方法，它就能够执行不同的代码。那么编译器是如何知道将要执行的是那段代码呢？

这也就是面向对象程序设计中最绝妙的地方：编译器不会产生传统意义上的函数调用。一个非面向对象编程的编译器产生的函数调用会引起所谓的***前期绑定***。
这意味着编译器将产生对一个具体函数名字的调用，而运行时将这个调用解析到要被执行的代码的绝对地址。

而在OOP语言中使用了***后期绑定*** 的概念。当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查
（无法提供这种保证的语言被称为是弱类型的），但是并不知道将被执行的确切代码。

为了执行后期绑定，Java使用一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。这样，根据这一小段代码的内容，
每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道对这条消息应该做些什么。

在有些语言中，必须明确地声明希望某个方法具有后期绑定属性（C++是使用virtual关键字来实现的）。在这些语言中，方法在默认情况下不是动态绑定的。
而在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。

把将导出类看做是它的基类的过程称为***向上转型***（upcasting）。

正是因为多态才使得事情总是能够被正确处理。编译器和运行系统会处理相关的细节，你只需要知道怎样通过它来设计程序。当向一个对象发送消息时，即使涉及向上转型，
该对象也会知道如何正确地执行。

---

### [上一节：继承](1.6_Inheritance.md)　　　　　　　　[下一节：单根继承结构](1.8_The_singly_rooted_hierarchy.md)