# 17.7 队列
Queue在Java SE5中仅有的实现是LinkedList和PriorityQueue，它们的差异在于排序行为而不是性能。看下面的示例：
```java
package containers;
import java.util.*;  
import java.util.concurrent.ArrayBlockingQueue;  
import java.util.concurrent.ConcurrentLinkedQueue;  
import java.util.concurrent.PriorityBlockingQueue;  

import net.mindview.util.Generator;

public class QueueBehavior {  
    private static int count = 10;  
    static <T> void test(Queue<T> queue, Generator<T> gen) {  
    	for(int i = 0; i < count; i++)  
    		queue.offer(gen.next());  
    	while(queue.peek() != null)  
    	    System.out.print(queue.remove() + " ");  
    	System.out.println();  
    }  
    private static class Gen implements Generator<String> {  
    	String[] s =   
    			("one two three four five six seven eight nine ten").split(" ");  
    	int index = 0;  
    	@Override  
    	public String next() {  
    		// TODO Auto-generated method stub  
    		return s[index++];  
    	}  
    }  
	public static void main(String[] args) {  
		// TODO Auto-generated method stub  
		test(new LinkedList<String>(), new Gen());  
		test(new PriorityQueue<String>(), new Gen());  
		test(new ArrayBlockingQueue<String>(count), new Gen());  
		test(new ConcurrentLinkedQueue<String>(), new Gen());  
		test(new PriorityBlockingQueue<String>(), new Gen());  
	}  
}/** Output:
one two three four five six seven eight nine ten 
eight five four nine one seven six ten three two 
one two three four five six seven eight nine ten 
one two three four five six seven eight nine ten 
eight five four nine one seven six ten three two 
**/
```
你可以看到，除了优先级队列，Queue将精确地按照元素被置于Queue中的顺序产生它们。

## 17.7.1 优先级队列
我们自定义一个队列，其中包含的每个对象包含一个字符串和一个主要的优先级和次要的优先级值。该列表的排序也是通过实现Comparable接口而进行控制的：
```java
package containers;

import java.util.PriorityQueue;

public class ToDoList extends PriorityQueue<ToDoList.ToDoItem> {
    static class ToDoItem implements Comparable<ToDoItem> {
    	char primary;
    	int secondary;
    	String item;
    	ToDoItem(String item, char primary, int secondary) {
    		this.item = item;
    		this.primary = primary;
    		this.secondary = secondary;
    	}
		@Override
		public int compareTo(ToDoItem arg) {
			// TODO Auto-generated method stub
			if(this.primary > arg.primary)
				return +1;
			else if(this.primary == arg.primary)
				if(this.secondary > arg.secondary)
					return  +1;
				else if(this.secondary == arg.secondary)
					return 0;
				else
					return -1;
			else
     			return -1;
		}
		public String toString() {
			return primary + String.valueOf(secondary) + ":" + item;
		}
    }
    public void add(String ite, char pri, int sec) {
    	super.add(new ToDoItem(ite, pri, sec));
    }
	public static void main(String[] args) {
		// TODO Auto-generated method stub
        ToDoList queue = new ToDoList();
        queue.add("Java", 'A', 1);
        queue.add("PHP", 'B', 1);
        queue.add("Python", 'A', 2);
        queue.add("C++", 'B', 2);
        queue.add("JavaScript", 'C', 2);
        queue.add("HTML", 'C', 1);
        while(queue.peek() != null)
        	System.out.println(queue.poll());
	}
}
/* Output:
A1:Java
A2:Python
B1:PHP
B2:C++
C1:HTML
C2:JavaScript
*/
```
可以看到各个项的输出顺序因为使用优先级队列，而自发的进行了排序。

**练习11：（2）创建一个类，包含一个Integer，其值通过使用java.util.Random被初始化为0到100之间的某个值。使用这个Integer域来实现Comparable。用这个类的对象
来填充PriorityQueue，然后使用poll()抽取这些值以展示该队列将按照我们预期的顺序产生这些值。**

***答案请戳 :point_right: [这里](solutions/Ex11.md)***

## 17.7.2 双向队列